<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALGORITMOS E PROGRAMAÇÃO II-T01-2023-2</title>
</head>
<body>

    <header>
        <h1>
            Módulo 3 <br>
            Unidade 1 - Recursão e algoritmos recursivos<br>
            <br>
            <a href="https://www.youtube.com/watch?v=rBc49w5FZxM">Vídeo 2 - Algoritmos e Programação de Computadores II - Recursão II</a>
        </h1>
        <p>
            Professor: Samuel Benjoino Ferraz Aquino <br>
            Professor: Marcelo G. Manzato
        </p>
    </header>

    <h4>Recursão II</h4>
    <p>
        <strong>Recursão vs. Iteração</strong>
        Problema: <br>
        n-ésimo de Fibonacci. <br>
        Quem é o melhor? <br>
        Estimativa de tempo para Fibonacci.
        <pre>
                n      10      20      30      50        100     
            Recursão  8 ms    1 s     2 s     21 dias   10<sup>9</sup>anos 
            Iteração  1/6 ms  1/3 ms  1/2 ms  3/4 ms    1/3 ms      
        </pre>
    </p>
    <p>
        Recursiva: <br>
        <pre>
            import time
            from memory_profiler import profile

            """
            Implementações em Python para calcular o n-ésimo termo da sequência de Fibonacci:
            de forma recursiva e iterativa:
            """
            @profile
            def fibonacci_recursivo(n):
                if n <= 1:
                    return n
                else:
                    return fibonacci_recursivo(n - 1) + fibonacci_recursivo(n - 2)

            # Execução
            inicio = time.time()
            resultado_recursivo_5 = fibonacci_recursivo(5)
            resultado_recursivo_10 = fibonacci_recursivo(10)
            resultado_recursivo_15 = fibonacci_recursivo(15)
            fim = time.time()
            tempo_recursivo_5 = fim - inicio
            tempo_recursivo_10 = fim - inicio
            tempo_recursivo_15 = fim - inicio

            print(f"Redultado Recursivo (n=5): {resultado_recursivo_5}") # 5
            print(f"Redultado Recursivo (n=10): {resultado_recursivo_10}") # 55
            print(f"Redultado Recursivo (n=15): {resultado_recursivo_15}") # 610

            print(f"Tempo Recursivo (n=5): {tempo_recursivo_5:.6f} segundos")
            print(f"Tempo Recursivo (n=10): {tempo_recursivo_10:.6f} segundos")
            print(f"Tempo Recursivo (n=15): {tempo_recursivo_15:.6f} segundos")

            # Filename: /home/normal/github/UFMS/algoritmos-e-programacao-2/0-modulo3_unidade_1_v2-recursao-e-algoritmos-recursivos.py

            # Line #    Mem usage    Increment  Occurrences   Line Contents
            # =============================================================
            #      8     48.7 MiB     48.7 MiB        1973   @profile
            #      9                                         def fibonacci_recursivo(n):
            #     10     48.7 MiB      0.0 MiB        1973       if n <= 1:
            #     11     48.7 MiB      0.0 MiB         987           return n
            #     12                                             else:
            #     13     48.7 MiB      0.0 MiB         986           return fibonacci_recursivo(n - 1) + fibonacci_recursivo(n - 2)


            # Redultado Recursivo (n=5): 5
            # Redultado Recursivo (n=10): 55
            # Redultado Recursivo (n=15): 610
            # Tempo Recursivo (n=5): 23.419869 segundos
            # Tempo Recursivo (n=10): 23.419869 segundos
            # Tempo Recursivo (n=15): 23.419869 segundos
        </pre>
 
        Iterativa: <br>
        <pre>
            import time
            from memory_profiler import profile

            """
            Implementações em Python para calcular o n-ésimo termo da sequência de Fibonacci:
            de forma recursiva e iterativa:
            """
            @profile
            def fibonacci_iterativo(n):
                if n <= 1:
                    return n
                
                a, b = 0, 1
                
                for _ in range(2, n + 1):
                    a, b = b, a + b

                return b

            # Execução
            inicio = time.time()
            resultado_iterativo_5 = fibonacci_iterativo(5)
            resultado_iterativo_10 = fibonacci_iterativo(10)
            resultado_iterativo_15 = fibonacci_iterativo(15)
            fim = time.time()
            fim_iterativo_5 = fim - inicio
            fim_iterativo_10 = fim - inicio
            fim_iterativo_15 = fim - inicio


            print(f"Resultado Iterativo (n=5): {resultado_iterativo_5}") # 5
            print(f"Resultado Iterativo (n=10): {resultado_iterativo_10}") # 55
            print(f"Resultado Iterativo (n=15): {resultado_iterativo_15}") # 610

            print(f"Tempo Iterativo (n=5): {resultado_iterativo_5:.6f} segundos")
            print(f"Tempo Iterativo (n=10): {resultado_iterativo_10:.6f} segundos")
            print(f"Tempo Iterativo (n=15): {resultado_iterativo_15:.6f} segundos")

            # Filename: /home/normal/github/UFMS/algoritmos-e-programacao-2/0-modulo3_unidade_1_v2-recursao-e-algoritmos-recursivos-2.py

            # Line #    Mem usage    Increment  Occurrences   Line Contents
            # =============================================================
            #      8     48.7 MiB     48.7 MiB           1   @profile
            #      9                                         def fibonacci_iterativo(n):
            #     10     48.7 MiB      0.0 MiB           1       if n <= 1:
            #     11                                                 return n
            #     12                                             
            #     13     48.7 MiB      0.0 MiB           1       a, b = 0, 1
            #     14                                             
            #     15     48.7 MiB      0.0 MiB          15       for _ in range(2, n + 1):
            #     16     48.7 MiB      0.0 MiB          14           a, b = b, a + b
            #     17                                         
            #     18     48.7 MiB      0.0 MiB           1       return b


            # Resultado Iterativo (n=5): 5
            # Resultado Iterativo (n=10): 55
            # Resultado Iterativo (n=15): 610
            # Tempo Iterativo (n=5): 5.000000 segundos
            # Tempo Iterativo (n=10): 55.000000 segundos
            # Tempo Iterativo (n=15): 610.000000 segundos
        </pre>
    </p>

    <h4>Memoização</h4>
    <p>
        A memoização é uma técnica de otimização que envolve armazenar resultados de chamadas de função e reutilizá-los quando a mesma entrada ocorre novamente. Isso é especialmente útil em algoritmos recursivos, onde os mesmos cálculos podem ser realizados várias vezes.
        <br><br>
        A ideia básica por trás da memoização é evitar recalcular resultados para os mesmos inputs, economizando tempo de processamento. Geralmente, isso é feito armazenando os resultados em uma estrutura de dados, como um dicionário.
    </p>
    <p>
        Ex.:
        <pre>
            """
            exemplo de memoização para melhorar o desempenho da função recursiva de Fibonacci:
            """
            def fibonacci_memoizacao(n, memo={}):
                if n <= 1:
                    return n
                
                # Verifica se o resultado já está memoizado
                if n not in memo:
                    # Se não estiver, calcula o resultado e armazena no dicionario memo
                    memo[n] = fibonacci_memoizacao(n - 1, memo) + fibonacci_memoizacao(n - 2, memo)

                return memo[n]

            # Execução
            resultado_memoizacao_5 = fibonacci_memoizacao(5)
            resultado_memoizacao_10 = fibonacci_memoizacao(10)
            resultado_memoizacao_15 = fibonacci_memoizacao(15)

            print(resultado_memoizacao_5) # 5
            print(resultado_memoizacao_10) # 55
            print(resultado_memoizacao_15) # 610
        </pre>
        - A memoização é alcançada através do uso de um dicionário (memo). Os resultados intermediários são armazenados nesse dicionário, e antes de calcular o resultado para um determinado n, a função verifica se esse resultado já está memoizado. Se estiver, o valor memoizado é retornado diretamente, economizando o tempo de cálculo.
        <br><br>
        - A memoização é uma técnica poderosa para melhorar a eficiência de algoritmos recursivos, especialmente em situações onde há muita repetição de cálculos para os mesmos inputs.
    </p>

    <h4>Exercício</h4>    
    <p>
        Dada uma lista l de n números, implemente uma função recursiva que retorna o maior elemento do conjunto.
        <pre>
            """
            Encontrar o Maior Elemento Recursivamente:
            """
            def maior_elemento_recursivo(lista):
                # Caso base: se a lista estiver vazia, retorna None
                if not lista:
                    return None
                
                # Caso base: se houver apenas um elemento, retorna esse elemento
                if len(lista) == 1:
                    return lista[0]
                
                # Passo recursivo: compara o primeiro elemento com o máximo do restante da lista
                max_resto = maior_elemento_recursivo(lista[1:])
                return lista[0] if lista[0] > max_resto else max_resto

            # Execução
            lista_teste = [3, 8, 2, 7, 5]
            resultado_maior_elemento = maior_elemento_recursivo(lista_teste)
            print(f"Maior Elemento: {resultado_maior_elemento}") # 8
        </pre>
    </p>
    <p>
        Dada uma lista l de n números, implemente uma função recursiva que retorna a soma de todos os elementos do conjunto.
        <pre>
            """
            Calcular a Soma Recursivamente:
            """
            def soma_elemento_recursivo(lista):
                # Se a lista estiver vazia, retorna 0
                if not lista:
                    return 0
                
                # Passo recursivo: soma o primeiro elemento com a soma do restante da lista
                return lista[0] + soma_elemento_recursivo(lista[1:])

            # Execução
            lista_teste = [3, 8, 2, 7, 5]
            resultado_soma_elemento = soma_elemento_recursivo(lista_teste)
            print(f"A soma dos Elementos: {resultado_soma_elemento}") # 25
        </pre>
    </p>
</body>
</html>