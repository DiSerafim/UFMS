<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALGORITMOS E PROGRAMA√á√ÉO II-T01-2023-2</title>
</head>
<body>

    <header>
        <h1>
            M√≥dulo 1 <br>
            Unidade 1 - No√ß√µes de gerenciamento de mem√≥ria e listas lineares sequenciais (homog√™neas e heterog√™neas)<br>
            <br>
            <a href="https://www.youtube.com/watch?v=_Eu9M15STbI">V√≠deo 1 - [UFMS Digital] Algoritmos e Programa√ß√£o II - M√≥dulo 1 - Unidade 1</a>
        </h1>
        <p>
            Professor: Samuel Benjoino Ferraz Aquino
        </p>
    </header>

    <h1>Listas lineares encadeadas</h1>

    <h4>Listas lineares</h4>
    <p>
        √â um conjunto de n >= 0 <strong>n√≥s/elementos</strong> organizados de acordo com as suas <strong>posi√ß√µes</strong> dentro da lista.
    </p>
    <pre>
        | "Alberto" | 10 | 10.5 | Jo√£o | 45 |
        |     0     |  1 |   2  |   3  |  4 |
    </pre>
    <p>
        Principais opera√ß√µes em uma lista linear. <br>
        - Busca. <br>
        - Inser√ß√£o. <br>
        - Remo√ß√£o.
    </p>
    <p>
        Custo dessas opera√ß√µes depende da implementa√ß√£o da linear. <br>
        - Lista linear com <strong>aloca√ß√£o sequencial</strong> <br>
        - Lista linear com <strong>aloca√ß√£o encadeada</strong>
    </p>

    <h4>Lista linear com aloca√ß√£o encadeada</h4>
    <p>
        - Alocar as posi√ß√µes da lista <strong>sob demanda</strong> e de maneira <strong>esparsa</strong> na mem√≥ria f√≠sica. <br>
        - Dada um lista linear <strong>L</strong> com aloca√ß√£o encadeada, os seus elementos est√£o <strong>espalhados</strong> na mem√≥ria f√≠sica.
    </p>

    <h4>Lista simplesmente encadeada</h4>
    <p>
        Uma posi√ß√£o de uma lista simplesmente encadeada √© chamada de <strong>n√≥</strong>. <br>
        
        Cada <strong>n√≥</strong> cont√©m: <br>
        - Conte√∫do (chave). <br>
        - Endere√ßo da pr√≥xima posi√ß√£o (prox). <br>

        Um <strong>n√≥</strong> √© uma <strong>vari√°vel simples heterog√™nea</strong>
    </p>
    <p>
        Exemplo:
        Lista simplesmente encadeada <strong>L</strong> com 3 elementos.
        L = []
        L.append(10)
        L.append(20)
        L.append(30)
        <pre>
            Endere√ßo | Conte√∫do
                0           10
                1           
                2           20
                3           
                4           
                5           30
        </pre>
    </p>
    <p>
        Como esperamos uma lista na mem√≥ria?
        <pre>
                  Cabe√ßa                                                          Fim
             _______‚Üì______________________________________________________________‚Üì________
            |       N√≥        | |        N√≥        | |        N√≥        | |        N√≥       |
            |Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo|
            |   -1   |        |‚Üí|    10   |        |‚Üí|    20   |        |‚Üí|    30   |  none |
        </pre>
    </p>
    <p>
        Declarando um n√≥.
        <pre>
            class No:
                def __init__(self, conteudo, proximo):
                    self.conteudo = conteudo
                    self.proximo = proximo


                        |       N√≥        |
                        |Conte√∫do|Pr√≥ximo |
                        |        |        |
                        -------------------
        </pre>
    </p>
    <p>
        Declarando uma lista simplesmente encadeada.
        <pre>
            class Lista:
                def __init__(self):
                    self.cabeca = No(-1, Nome)
                    self.fim = self.cabeca


                    Cabe√ßa     Fim
                    _________________
                   |        N√≥       |
                   |Conte√∫do|Pr√≥ximo |
                   |   -1   |  none  |
        </pre>
    </p>
    <p>
        Considere as seguintes opera√ß√µes em uma lista linear <strong>L</strong> com aloca√ß√£o encadeada: <br>
        - <strong>Imprimir</strong> o conte√∫do da lista. <br>
        - <strong>Inserir</strong> um elemento <strong>x</strong> no final da lista. <br>
        - <strong>Buscar</strong> um elemento <strong>x</strong> <br>
        - <strong>Remover</strong> um elemento <strong>x</strong>
    </p>
    <p>-----------------------</p>
    <p>
        <strong>Imprimir</strong> o conte√∫do da lista.
        <pre>
                  Cabe√ßa                                                          Fim
             _______‚Üì______________________________________________________________‚Üì________
            |       N√≥        | |        N√≥        | |        N√≥        | |        N√≥       |
            |Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo|
            |   -1   |        |‚Üí|    10   |        |‚Üí|    20   |        |‚Üí|    30   |  none |
        </pre>

        <pre>
                atual = self.cabeca.proximo

                        atual
                __________‚Üì________
                |        N√≥        | 
                | Conte√∫do|Pr√≥ximo | 
                |    10   |        |‚Üí
        </pre>
        <pre>
            class Lista:
            ...
                def imprime(self):
                    atual = self.cabeca.proximo
                    while(atual != None):
                        print(atual.conteudo)
                        atual = atual.proximo
        </pre>
    </p>
    <p>-----------------------</p>
    <p>

        <strong>Inserir</strong> um elemento <strong>x</strong> no final da lista.
        <pre>
                  Cabe√ßa                                                          Fim
             _______‚Üì______________________________________________________________‚Üì________
            |       N√≥        | |        N√≥        | |        N√≥        | |        N√≥       |
            |Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo|
            |   -1   |        |‚Üí|    10   |        |‚Üí|    20   |        |‚Üí|    30   |  none |
        </pre>

        <pre>
                novo = No(x, None)
                self.fim.proximo = novo
                self.fim = novo


                        novo
                __________‚Üì________
                |        N√≥        | 
                | Conte√∫do|Pr√≥ximo | 
                |    x    |  None  |
        </pre>
        <pre>
            class Lista:
            ...
                def insereNoFim(self, x):
                    novo = No(x, None)
                    self.fim.proximo = novo
                    self.fim = novo
        </pre>
    </p>
    <p>-----------------------</p>
    <p>
        <strong>Buscar</strong> um elemento <strong>x</strong>
        <pre>
                  Cabe√ßa                                                          Fim
             _______‚Üì______________________________________________________________‚Üì________
            |       N√≥        | |        N√≥        | |        N√≥        | |        N√≥       |
            |Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo|
            |   -1   |        |‚Üí|    10   |        |‚Üí|    20   |        |‚Üí|    30   |  none |
        </pre>

        <pre>
                atual = self.cabeca.proximo

                        atual
                __________‚Üì________
                |        N√≥        | 
                | Conte√∫do|Pr√≥ximo | 
                |    10   |        |‚Üí

                atual.conteudo == x ? üëé
                atual = self.cabeca.proximo
                atual = atual.proximo

                        atual
                __________‚Üì________
                |        N√≥        | 
                | Conte√∫do|Pr√≥ximo | 
                |    20   |        |‚Üí

                atual.conteudo == x ? üëçüòÉ

        </pre>
        <pre>
            class Lista:
            ...
                def buscar(self, x):
                    atual = self.cabeca.proximo
                    while(atual != None):
                        if atual.conteudo == x:
                            return True
                        atual = atual.proximo
                    return False
        </pre>
    </p>
    <p>-----------------------</p>
    <p>
        <strong>Remover</strong> um elemento <strong>x (20)</strong>
        <pre>
                  Cabe√ßa                                                          Fim
             _______‚Üì______________________________________________________________‚Üì________
            |       N√≥        | |        N√≥        | |        N√≥        | |        N√≥       |
            |Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo|
            |   -1   |        |‚Üí|    10   |        |‚Üí|    20   |        |‚Üí|    30   |  none |
        </pre>

        <pre>
                atual = self.cabeca.proximo

                        atual
                __________‚Üì________
                |        N√≥        | 
                | Conte√∫do|Pr√≥ximo | 
                |    10   |        |‚Üí

                atual.conteudo == x ? üëé
                atual = atual.proximo

                        atual
                __________‚Üì________
                |        N√≥        | 
                | Conte√∫do|Pr√≥ximo | 
                |    20   |        |‚Üí

                atual.conteudo == x ? üëçüòÉ
                anterior.proximo = atual.proximo
                atual.proximo = None


            <pre>
                    Cabe√ßa                anterior               Fim
                _______‚Üì_____________________‚Üì____________________‚Üì________
                |       N√≥        | |        N√≥        | |        N√≥       |
                |Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo | | Conte√∫do|Pr√≥ximo|
                |   -1   |        |‚Üí|    10   |        |‚Üí|    30   |  none |
            </pre>
        </pre>
        <pre>
            class Lista:
            ...
                anterior = self.cabeca
                atual = self.cabeca.proximo

                while(atual != None):
                    if atual.conteudo == x:
                    anterior.proximo = atual.proximo
                    atual.proximo = None
                    break

                    anterior = atual
                    atual = atual.proximo

                if self.fim.coteudo == x:
                    self.fim = anterior
        </pre>
    </p>

    <h4>Resumo</h4>
    <p>
        Lista simplesmente encadeada <br>
        - Impress√£o <br>
        - Inser√ß√£o <br>
        - Busca <br>
        - Remo√ß√£o <br>
        <br>
        Vantages e desvantagens
    </p>
</body>
</html>