<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 1 - Hash e Heap.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 1 - Hash e Heap.</h1>
        <h2>üí° Unidade 1 - Tabelas de Dispers√£o: Hash.</h2>
        <p>Prof¬∞ Especialista: Gedson Faria, Graziela Santos de Ara√∫jo e Jonathan de Andrade Silva.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>ESTRUTURA DE DADOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=jQ0r7P8rC1M&ab_channel=UNIVESP" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 4 - 
                Estruturas de Dados - Conceitos de Tabela Hash. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Prof¬∞ ministrante: Ulisses Martins Dias.</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Conceitos de Tabela Hash.</h3>
            <b>Roteiro:</b>
            <ul>
                <li>Motiva√ß√£o.</li>
                <li>Tipo Abstrato de Dados.</li>
                <li>Detalhes de Implementa√ß√£o.</li>
                <li>Fun√ß√µes de Hash.</li>
            </ul>
        </section>

        <section>
            <h2>Motiva√ß√£o.</h2>
            <ul>
                <li>Sabemos que:</li>
                <ul>
                    <li>Busca sequencial executa em tempo O(n).</li>
                    <li>Busca bin√°ria executa em tempo O(log(n)).</li>
                    <li>Busca bin√°ria exige vetor ordenado.</li>
                </ul>
                <li>Seria poss√≠vel efetuar uma busca em tempo melhor do que O(log(n))?</li>
                <li>Quais restri√ß√µes devem existir sobre os dados?</li>
                <li>Tabelas de Hash (ou Tabelas Hash) permitem buscas em tempo constante, satisfeitas algumas restri√ß√µes.</li>
                <li>Essa estrutura pode ter v√°rios nomes como: dicion√°rios, mapas, arrays associativos, e assim por diante.</li>
                <li>A princ√≠pio, a chave de busca pode ser de qualquer tipo.</li>
            </ul>
        </section>

        <section>
            <h2>Tipo Abstrato de Dados.</h2>
            <ul>
                <li><b>retrieveltem(k)</b>: retorna uma entrada com chave igual a k, se ela existir. Caso contr√°rio, retorna nulo.</li>
                <li><b>insertltem(k, v)</b>: insere uma entrada v na chave k se a chave n√£o existir. Caso contr√°rio, atualiza o valor associado a k.</li>
                <li><b>deleteltem(k)</b>: remove a chave k e o valor associado a ela.</li>
            </ul>
            <b>Outros M√©todos:</b>
            <ul>
                <li><b>size()</b>: retorna o n√∫mero de entradas.</li>
                <li><b>keySet()</b>: retorna uma lista encadeada de todas as chaves armazenadas na tabela.</li>
                <li><b>values()</b>: retorna uma cole√ß√£o contendo todos os valores associados com as chaves armazenadas na tabela.</li>
                <li><b>entrySet()</b>: retorna uma cole√ß√£o contendo todas as entradas (chave-valor) da tabela.</li>
            </ul>
        </section>

        <section>
            <h2>Implementa√ß√£o.</h2>
            <ul>
                <li>A pr√≥pria chave deve ser usada para organizar os dados em mem√≥ria.</li>
                <li>Cada entrada da estrutura √© composta por um par "chave-valor" (k, v). A associa√ß√£o entre k e v define o mapeamento.</li>
                <li>A chave √© um identificador √∫nico e deve ser vista como um "endere√ßo" para seu valor.</li>
                <li>A tabela pode ser organizada em mem√≥ria como um vetor, dado que este permite acesso em tempo constante.</li>
                <li>As chaves podem ser de qualquer tipo de dados, mas para efetuarmos a busca no vetor, precisaremos de uma fun√ß√£o que mapeie chaves em n√∫meros inteiros.</li>
            </ul>
            <img src="img/tabela-hash.png" alt="tabela-hash.png">
            <ul>
                <li>Seja h a fun√ß√£o que faz o mapeamento (tamb√©m chamada de fun√ß√£o de espalhamento) e k a chave, o endere√ßo de mem√≥ria ser√° dado por h(k).</li>
                <li>Se os valores retornados por h(k) forem bem distribu√≠dos em um intervalo entre 0 e N-1, ent√£o precisamos de um vetor de capacidade N.</li>
                <li>Assumindo aus√™ncia de colis√µes, essa estrutura b√°sica seria suficiente.</li>
            </ul>
            <img src="img/tabela-hash1.png" alt="tabela-hash1.png">
        </section>

        <section>
            <h2>Fun√ß√µes de Hash.</h2>
            <ul>
                <li>A fun√ß√£o de hash h mapeia cada chave em um intervalo de 0 a N-1, onde N√© a capacidade do arranjo.</li>
                <li>√â poss√≠vel tratar colis√µes, mas a melhor estrat√©gia por enquanto √© tentar evit√°-las.</li>
                <li>Uma fun√ß√£o de hash √© boa se minimiza a ocorr√™ncia de colis√µes.</li>
                <li>A primeira tarefa da fun√ß√£o ser√° transformar chaves de tipos arbitr√°rios em inteiros.</li>
                <li>Vamos assumir que queremos armazenar informa√ß√µes de funcion√°rios de uma empresa e indexar essas informa√ß√µes pelo login √∫nico da pessoa.</li>
                <li>O login pode ser o primeiro nome da pessoa, mas se este j√° foi escolhido por algu√©m, ent√£o outro deve ser selecionado pelo funcion√°rio.</li>
            </ul>
            <p>Uma fun√ß√£o de hash pode primeiramente mapear os caracteres para inteiros:</p>
            <img src="img/tabela-hash2.png" alt="tabela-hash2.png">
            <p>Podemos mapear qualquer login em inteiro:</p>
            <pre>
            ulisses     776
            danielle    830
            amanda      610
            cle√≥patra   1218
            </pre>
            <ul>
                <li>O valor inteiro encontrado pode ser o √≠ndice da entrada em um vetor.</li>
                <li>Essa ideia ilustra uma implementa√ß√£o b√°sica da tabela hash.</li>
            </ul>
            <p>Essa estrat√©gia gera colis√µes:</p>
            <pre>
            orlando     751
            odnalro     751
            adriana     720
            ariadna     720
            </pre>
            <p>Uma fun√ß√£o de hash melhor levaria em conta a posi√ß√£o dos caracteres c‚ÇÅ na cadeia <b>C = (Co, C1, C2,..., Ck-1).</b></p>
            <pre>C‚ÇÄa·¥∑‚Åª¬π + C‚ÇÅa·¥∑‚Åª¬≤ + C‚ÇÇa·¥∑‚Åª¬≥ + ... + C‚Çñ‚Çã‚ÇÇa¬π+C‚Çñ‚Çã‚ÇÅ</pre>
            <p>Para algum <b>a</b> diferente de <b>0</b> ou <b>1</b>.</p>
            <ul>
                <li>Por exemplo, com a = 3, ter√≠amos os seguintes valores para orlando e odnalro:</li>
                <img src="img/tabela-hash3.png" alt="tabela-hash3.png">
                <li>Um valor de a alto (33, 37, 39 ou 41) tende a diminuir o n√∫mero de colis√µes para algumas poucas.</li>
            </ul>
            <p>Nesse caso, √© poss√≠vel fazer com que cada endere√ßo tenha espa√ßo para mais de uma entrada.</p>
            <img src="img/tabela-hash4.png" alt="tabela-hash4.png">
            <ul>
                <li>Um valor de a alto (33, 37, 39 ou 41) pode levar a um overflow do intervalo dos inteiros.</li>
                <li>A compress√£o dos valores pode fazer parte da fun√ß√£o. O resto da divis√£o por N estabiliza os valores em um intervalo [0.. N-1].</li>
                <pre>i mod N</pre>
                <li>O tamanho do arranjo N pode aumentar ou diminuir o n√∫mero de colis√µes:</li>
                <ul>
                    <li>Se usarmos N = 1000, teremos muito menos colis√µes do que com N = 100.</li>
                </ul>
                <li>Para ajudar o espalhamento das chaves, √© interessante usar um n√∫mero primo para N. Isso diminui a chance de ocorrer padr√µes na distribui√ß√£o de dados.</li>
                <li>Por exemplo, se temos as chaves {200, 205, 210, 215, 220,..., 600}.</li>
                <ul>
                    <li>Com N = 100, cada chave ir√° colidir com v√°rias outras chaves.</li>
                    <li>Com N = 101 n√£o teremos colis√µes.</li>
                </ul>
                <li>Na pr√≥xima aula, implementaremos esses conceitos em C++. Em seguida, veremos t√©cnicas de tratamento de colis√£o.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 24 de maio de 2024</p>
    </footer>
</body>
</html>
