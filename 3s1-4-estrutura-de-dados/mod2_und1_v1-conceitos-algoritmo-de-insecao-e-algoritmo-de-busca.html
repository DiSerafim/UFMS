<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 2 ‚Äì √Årvore Bin√°ria de Busca.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 2 ‚Äì √Årvore Bin√°ria de Busca.</h1>
        <h2>üí° Unidade 1 - Conceitos, algoritmo de inser√ß√£o e algoritmo de busca.</h2>
        <p>Prof¬∞ Especialista: Gedson Faria, Graziela Santos de Ara√∫jo e Jonathan de Andrade Silva.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>ESTRUTURA DE DADOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=mGoYmyDbZIY&ab_channel=AGEADUFMS" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 1 - 
                [UFMS Digital] Estrutura de Dados - M√≥dulo 2 - Unidade 1.
                <i class="material-icons right"> send</i>
            </a>
            <p>Prof¬∞ ministrante: Dr. Jonathan de Andrade Silva.</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Conceitos, algoritmo de inser√ß√£o e algoritmo de busca.</h3>
            <p>PARTE 1</p>
        </section>

        <section>
            <h2>Pesquisa Linear.</h2>
            <ul>
                <li>Considere um vetor V de valores ordenados V= [1,3,5,7,9,11,13] e desejamos buscar o valor <b>15</b>, que n√£o existe em V.</li>
                <ul>
                    <li>Na busca convencional perguntamos de i=0 at√© i=6:</li>
                    <ul>
                        <li>V[i] == 15? (7 passos);</li>
                        <li>Custo da busca O(N).</li>
                    </ul>
                </ul>
            </ul>
            <img src="img/pesquisa-linear.png" alt="pesquisa-linear.png">
        </section>

        <section>
            <h2>Pesquisa Bin√°ria.</h2>
            <ul>
                <li>Essa estrat√©gia assume que o conjunto de dados deve estar <b>ordenado</b> (crescente ou decrescente);</li>
                <li>Inicia a busca pela <b>posi√ß√£o central</b> do conjunto de dados;</li>
                <ul>
                    <li>Se n√£o for o elemento a ser buscado, <b>divide</b> o conjunto em duas metades, continuando a busca na metade onde o elemento pode estar;</li>
                    <li>Esse processo √© repetido at√© encontrar o elemento desejado ou chegar ao fim do conjunto de dados. Pesquisa Bin√°ria</li>
                </ul>
                <li>Considere um vetor V de valores ordenados V= [1,3,5,7,9,11,13] e desejamos buscar o valor <b>15</b>, que n√£o existe em V.</li>
            </ul>
            <img src="img/pesquisa-binaria.png" alt="pesquisa-binaria.png">
            <ul>
                <li>Problema:</li>
                <ul>
                    <li>Manter o vetor ordenado!</li>
                    <li>Se aplicar a ordena√ß√£o em cada opera√ß√£o de inser√ß√£o e remo√ß√£o o custo fica alto!</li>
                    <li>Custo da inser√ß√£o/remo√ß√£o + custo da ordena√ß√£o!</li>
                </ul>
                <li>Solu√ß√£o:</li>
                <ul>
                    <li>√Årvore de Busca Bin√°ria!</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>√Årvore de Busca Bin√°ria.</h2>
            <ul>
                <li>Como vimos no m√≥dulo anterior sobre Heap, na √°rvore bin√°ria temos:</li>
                <ul>
                    <li>Cada n√≥ possui at√© 2 filhos (FE e FD);</li>
                    <li>A altura (h) da √°rvore √© igual ao n√∫mero de n√≠veis -1;</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria.png" alt="busca-binaria.png">
            <p></p>
            <img src="img/busca-binaria1.png" alt="busca-binaria1.png">
            <ul>
                <li>A √°rvore a baixo √© bin√°ria?</li>
                <ul>
                    <li>N√£o!</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria2.png" alt="busca-binaria2.png">
            <ul>
                <li>A √°rvore a baixo √© bin√°ria?</li>
                <ul>
                    <li>N√£o! Por qu√™?</li>
                    <ul>
                        <li>6 Viola a propriedade.</li>
                    </ul>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria3.png" alt="busca-binaria3.png">
            <ul>
                <li>A √°rvore a baixo √© bin√°ria?</li>
                <ul>
                    <li>Agora sim!</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria4.png" alt="busca-binaria4.png">
            <ul>
                <li>A √°rvore a baixo √© bin√°ria?</li>
                <ul>
                    <li>Agora sim!</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria5.png" alt="busca-binaria5.png">
            <ul>
                <li>Como podemos organizar os valores de 1 a 6 nessa √°rvore?</li>
                <ul>
                    <li>Onde colocar o menor e o maior valor?</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria6.png" alt="busca-binaria6.png">
            <ul>
                <li>Como podemos organizar os valores de 1 a 6 nessa √°rvore?</li>
                <ul>
                    <li>Qual valor vai na raiz?</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria7.png" alt="busca-binaria7.png">
            <ul>
                <li>Como podemos organizar os valores de 1 a 6 nessa √°rvore?</li>
                <ul>
                    <li>E os demais 2, 3 e 5?</li>
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>
            <img src="img/busca-binaria8.png" alt="busca-binaria8.png">
            <ul>
                <li>Como podemos organizar os valores de 1 a 6 nessa √°rvore?</li>
                <ul>
                    <li>E se a √°rvore fosse assim ‚Ü¥</li>
                    <img src="img/busca-binaria9.png" alt="busca-binaria9.png">
                    <li>Ter√≠amos ‚Ü¥</li>
                    <img src="img/busca-binaria10.png" alt="busca-binaria10.png">
                    <li>Comparando as duas √°rvores bin√°rias, temos:</li>
                    <img src="img/busca-binaria11.png" alt="busca-binaria11.png">
                    <li>Poder√≠amos ter outras configura√ß√µes de √°rvore bin√°ria para os mesmos valores;</li>
                    <ul>
                        <li>Depende da ordem de inser√ß√£o dos elementos.</li>
                    </ul>
                    <img src="img/busca-binaria12.png" alt="busca-binaria12.png">
                </ul>
                <li>Propriedade:</li>
                <ul>
                    <li>B < A < C</li>
                    <li>B √© o Menor</li>
                    <li>C √© o Maior</li>
                </ul>
            </ul>

            <b>Tipos de √°rvores bin√°rias:</b>
            <ul>
                <li><b>Degenerada</b>: cada n√≥ possui exatamente 1 filho (n¬∞ de n√≠veis = n¬∞ de n√≥s);</li>
                <li><b>Quase-Completa</b>: cada n√≠vel, exceto o √∫ltimo est√° completamente preenchido;</li>
                <li><b>Completa</b>: todos os n√≠veis est√£o completamente preenchidos;</li>
                <li><b>Cheia</b> (completa): todos os n√≥s, <b>exceto os do √∫ltimo n√≠vel</b> possuem exatamente 2 sub√°rvores.</li>
                <li><b>Estritamente Bin√°ria</b>: todo n√≥ tem <b>0 ou 2 filhos</b>.</li>
            </ul>
            <img src="img/busca-binaria13.png" alt="busca-binaria13.png">
            <ul>
                <li>Nessa estrutura de dados gostar√≠amos de evitar obter √°rvores bin√°rias degeneradas.</li>
                <li>Caso tenhamos √°rvores quase-completas ou completas, ter√≠amos um √≥timo desempenho na inser√ß√£o, remo√ß√£o e busca.</li>
                <ul>
                    <li>De O(N) para O(log2N)!</li>
                </ul>
            </ul>
            <img src="img/busca-binaria14.png" alt="busca-binaria14.png">
        </section>

        <section>
            <h2>√Årvore Bin√°ria (Inser√ß√£o).</h2>
            <ul>
                <li>Em geral, consiste na opera√ß√£o de incluir elementos nas sub√°rvores esquerda ou direita da raiz;</li>
                <li>Pode modificar a altura da √°rvore dependendo de onde for o local apropriado de inser√ß√£o;</li>
                <ul>
                    <li>Pode resultar nos tipos de √°rvores comentados anteriormente, por exemplo, √°rvores degeneradas.</li>
                </ul>
                <li>Deve garantir a <b>propriedade</b> da √°rvore de busca bin√°ria.</li>
                <li>Todo o processo de caminhada na √°rvore inicia-se na <b>raiz</b>;</li>
                <li>Precisamos encontrar em qual <b>local</b> na √°rvore podemos incluir o novo n√≥;</li>
                <li>Esse processo de inclus√£o sempre produzir√° um <b>n√≥ folha</b>;</li>
                <li>Esse novo n√≥ se tornar√° um filho esquerdo (<b>FE</b>) ou filho direito (<b>FD</b>) do seu ancestral.</li>
                <ul>
                    <li>Temos que encontrar o seu ancestral.</li>
                </ul>
                <li>Vamos visualizar o processo de inser√ß√£o no <b>VISUALGO</b> (https://visualgo.net/en/bst);</li>
                <ul>
                    <li>Vamos criar uma √°rvore vazia (‚ÄúCreate‚Äù -> ‚ÄúEmpty‚Äù)</li>
                    <li>Aplicar a fun√ß√£o de inser√ß√£o para os valores (‚ÄúInsert(v)‚Äù):</li>
                    <ul>
                        <li>A = [1,2,3,4,7,8]</li>
                        <li>B = [4,2,7,1,3,8]</li>
                    </ul>
                    <li>Qual dessas √°rvores √© uma √°rvore bin√°ria degenerada (A ou B)? A. Observe a organiza√ß√£o dos valores.</li>
                </ul>
            </ul>
            <b>Inserir o valor 5 nas √°rvores abaixo:</b>
            <p></p>
            <img src="img/arvore-binaria2.png" alt="arvore-binaria2.png">
            <p></p>
            <img src="img/arvore-binaria3.png" alt="arvore-binaria3.png">
            <ul>
                <li>Precisamos saber quando inserir na <b>raiz</b> ou <b>buscar</b> nas sub√°rvores da esquerda ou direita o local de inser√ß√£o.</li>
                <ul>
                    <li>Inserir na raiz √© quando a √°rvore est√° vazia;</li>
                    <ul>
                        <li>Qual a configura√ß√£o de √°rvore vazia? Raiz sem n√≥.</li>
                        <li>Fazer a raiz ser esse novo n√≥.</li>
                    </ul>
                    <li>Se a √°rvore tem raiz, ent√£o devemos buscar o local de inser√ß√£o‚Ä¶</li>
                    <li>Se a √°rvore tem raiz ent√£o devemos buscar o local de inser√ß√£o.</li>
                    <ul>
                        <li>Percorrer/<b>buscar</b> desde a raiz e perguntar se o novo n√≥ deve estar na sub√°rvore da esquerda ou da direita;</li>
                        <ul>
                            <li>novo < n√≥ atual: ir para FE;</li>
                            <li>novo > n√≥ atual: ir para FD;</li>
                            <li>novo = n√≥ atual:  <b>n√£o inserir</b>.</li>
                            <ul>
                                <li>Podemos gerar uma √°rvore degenerada.</li>
                            </ul>
                        </ul>
                    </ul>
                </ul>
            </ul>
        </section>

        <section>
            <h2>√Årvore Bin√°ria (Busca).</h2>
            <ul>
                <li>Caminhar na √°rvore desde a raiz para <b>encontrar um elemento</b> ou <b>encontrar uma posi√ß√£o de inser√ß√£o</b> para um novo elemento;</li>
                <ul>
                    <li>Na busca por um elemento vamos realizar a busca para <b>encontrar um valor</b>;</li>
                    <li>Na busca por uma posi√ß√£o de inser√ß√£o vamos realizar a busca para <b>encontrar um ‚Äúramo‚Äù sem filho</b> (FE=vazio ou FD=vazio).</li>
                </ul>
                <li>Vamos assumir que a estrutura de dados que representa o nosso n√≥ tem 3 campos:</li>
                <ul>
                    <li><b>chave</b>: contendo o valor;</li>
                    <li><b>FE</b>: contendo refer√™ncia ao filho esquerdo;</li>
                    <li><b>FD</b>: contendo refer√™ncia ao filho direito.</li>
                </ul>
                <li>Buscar o valor 5</li>
                <ul>
                    <li>no = buscar(raiz,5)</li>
                </ul>
            </ul>
            <pre>
            Buscar(raiz,valor):
                no_atual = raiz
                Enquanto no_atual ‚â† vazio e no_atual.chave ‚â† valor fa√ßa
                    Se valor < no_atual.chave Ent√£o
                        no_atual = no_atual.FE
                    Sen√£o
                        no_atual = no_atual.FD
                retorna no_atual
            </pre>
            <img src="img/arvore-binaria4.png" alt="arvore-binaria4.png">
        </section>

        <section>
            <h2>√Årvore Bin√°ria (Inser√ß√£o).</h2>
            <ul>
                <li>Agora que temos o algoritmo da busca, podemos criar o algoritmo de inser√ß√£o.</li>
                <ul>
                    <li>Por√©m, temos que ajustar a busca para obter tamb√©m o <b>ancestral</b>;</li>
                    <li>Lembrando: Se a √°rvore tem raiz, ent√£o devemos <b>buscar o local de inser√ß√£o</b>.</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria5.png" alt="arvore-binaria5.png">
            <p></p>
            <img src="img/arvore-binaria6.png" alt="arvore-binaria6.png">
            <p></p>
            <img src="img/arvore-binaria7.png" alt="arvore-binaria7.png">
            <p>Agora que ajustamos a busca para ter acesso ao n√≥ ancestral, podemos definir o algoritmo de inser√ß√£o.</p>
            <img src="img/arvore-binaria8.png" alt="arvore-binaria8.png">
            <ul>
                <li>Ap√≥s a adapta√ß√£o do algoritmo de busca, temos:</li>
                <ul>
                    <li>Buscar o ancestral:</li>
                    <ul>
                        <li>no, anc = buscar(raiz,valor)</li>
                    </ul>
                    <li>Conectar esse ancestral com o novo n√≥:</li>
                    <ul>
                        <li>Se valor < anc.valor Ent√£o</li>
                        <ul>
                            <li>anc.FE = novo</li>
                        </ul>
                        <li>Sen√£o Se valor > anc.valor Ent√£o</li>
                        <ul>
                            <li>anc.FD = novo</li>
                        </ul>
                    </ul>
                </ul>
                <li>Como devem ficar os campos do novo n√≥ ap√≥s ‚ÄúCriaNo‚Äù?</li>
                <ul>
                    <li>campo chave = valor;</li>
                    <li>filhos FE e FD = vazio.</li>
                </ul>
            </ul>
            <pre>
            inserir(valor):
                novo = criaNo(valor)
                no, anc = buscar(raiz,valor)
                <b>Se</b> no = vazio <b>Ent√£o</b>
                    <b>Se</b> valor < anc.valor <b>Ent√£o</b>
                        anc.FE = novo
                    <b>Sen√£o Se</b> valor > anc.valor <b>Ent√£o</b>
                        anc.FD = novo
            </pre>
        </section>

        <section>
            <h2>√Årvore Bin√°ria (An√°lise).</h2>
            <ul>
                <li>Conforme observamos, a inser√ß√£o depende da busca de um local para inserir um novo n√≥.</li>
                <li>O custo da inser√ß√£o depende do n√∫mero de passos dessa busca:</li>
                <ul>
                    <li>Caminhar em toda a altura da √°rvore;</li>
                    <li>Complexidade de custo no pior caso O(N), se a √°rvore for degenerada.</li>
                    <ul>
                        <li>Se a √°rvore for completa ou quase-completa o custo fica em O(log2 N).</li>
                    </ul>
                </ul>
                <li>Qual o <b>melhor</b> local de inser√ß√£o de um novo n√≥?</li>
                <ul>
                    <li>Filho esquerdo de 4.</li>
                </ul>
                <li>Qual o <b>pior</b> local de inser√ß√£o de um novo n√≥?</li>
                <ul>
                    <li>Filho (FE ou FD) do n√≥ 9.</li>
                </ul>
                <li>Qual a <b>altura</b> da √°rvore?</li>
                <ul>
                    <li>altura (h=3).</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria9.png" alt="arvore-binaria9.png">
        </section>

        <section>
            <h2>Implementa√ß√£o em Python.</h2>
            <h3>PARTE II.</h3>
        </section>

        <section>
            <h2>√Årvore Bin√°ria (Estrutura de Dados).</h2>
            <ul>
                <li>Podemos implementar a nossa √°rvore com 2 tipos de estrutura de dados:</li>
                <ul>
                    <li>Vetor/Array, como fizemos na Heap.</li>
                    <ul>
                        <li>Acesso direto aos n√≥s da √°rvore;</li>
                        <li>Por√©m, o tamanho da √°rvore fica <b>fixo</b>.</li>
                    </ul>
                    <li>Utilizando Listas Ligadas.</li>
                    <ul>
                        <li>N√£o temos acesso direto aos n√≥s;</li>
                        <li>Por√©m, o tamanho da √°rvore √© <b>din√¢mico</b>.</li>
                    </ul>
                </ul>
                <li>Vamos considerar ent√£o as Listas Ligadas.</li>
                <ul>
                    <li>Queremos ter flexibilidade para inser√ß√£o e remo√ß√£o;</li>
                </ul>
                <li>Vamos considerar que cada n√≥ tenha:</li>
                <ul>
                    <li>campo <b>chave</b> = valor;</li>
                    <li>campo <b>FE</b> = refer√™ncia ao filho esquerdo;</li>
                    <li>campo <b>FD</b> = refer√™ncia ao filho direito.</li>
                </ul>
                <li>Vamos considerar tamb√©m que a estrutura de dados √Årvore Bin√°ria de Busca(ABB), pode ter:</li>
                <ul>
                    <li>campo <b>raiz</b> = refer√™ncia ao primeiro n√≥ da √°rvore;</li>
                    <li>campo <b>h</b> = indicando a altura da √°rvore.</li>
                    <li>fun√ß√µes de manuten√ß√£o:</li>
                    <ul>
                        <li>Inser√ß√£o, remo√ß√£o, busca, altura,...etc.</li>
                    </ul>
                </ul>
                <li>Como conectar os n√≥s 7 e 5 na raiz?</li>
                <ul>
                    <li>raiz.fe = b;</li>
                    <li>raiz.fd = a.</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria10.png" alt="arvore-binaria10.png">
            <p>C√≥digo (https://pythontutor.com/render.html#mode=display)</p>
            <img src="img/arvore-binaria11.png" alt="arvore-binaria11.png">
            <ul>
                <li>E se fizermos uma fun√ß√£o chamada <b>conectar</b> para fazer essa liga√ß√£o, como seria?</li>
                <ul>
                    <li>lembre que temos que saber quais n√≥s devem ir para esquerda ou direita da raiz.</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria12.png" alt="arvore-binaria12.png">
            <ul>
                <li>Se o n√≥ tiver valor <b>menor</b> que a <b>raiz</b>, devemos conectar o <b>n√≥</b> com <b>fe</b> da raiz;</li>
                <li>Se o <b>n√≥</b> tiver valor <b>maior</b> que a <b>raiz</b>, devemos conectar o <b>n√≥</b> com <b>fd</b> da raiz;</li>
            </ul>
            <img src="img/arvore-binaria13.png" alt="arvore-binaria13.png">
            <ul>
                <li>Vamos agora come√ßar pela nossa fun√ß√£o de <b>busca</b>.</li>
                <ul>
                    <li>Percorrer desde a raiz e encontrar <b>um valor</b> ou <b>local</b> de inser√ß√£o.</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria14.png" alt="arvore-binaria14.png">
            <ul>
                <li>Iniciar pela raiz e percorrer a √°rvore com duas vari√°veis:</li>
                <ul>
                    <li><b>anc</b>: ancestral (pai).</li>
                    <li><b>no_atual</b>: n√≥ a ser buscado.</li>
                </ul>
                <li>Por exemplo, <b>buscar(raiz, 6)</b></li>
                <ul>
                    <li>buscar o n√≥ com valor 6.</li>
                    <li><b>anc</b> = no(7) e <b>no_atual</b> = no(6)</li>
                </ul>
            </ul>
            <b>√Årvore Bin√°ria (Busca):</b>
            <pre>
            buscar(raiz,valor):
                <b>no_anc</b> = vazio
                no_atual = raiz
                <b>Enquanto</b> no_atual ‚â† vazio <b>e</b> no_atual ‚â† valor <b>fa√ßa</b>
                    <b>no_anc</b> = no_atual
                    <b>Se</b> valor < no_atual.chave <b>Ent√£o</b>
                        no_atual = no_atual.FE
                    <b>Sen√£o</b>
                        no_atual = no_atual.FD
                <b>retornar</b> no_atual, <b>no_anc</b>
            </pre>
            <img src="img/arvore-binaria15.png" alt="arvore-binaria15.png">
            <p></p>
            <img src="img/arvore-binaria17.png" alt="arvore-binaria17.png">
            <p></p>
            <b>√Årvore Bin√°ria (Inser√ß√£o):</b>
            <ul>
                <li>Juntando todas as fun√ß√µes‚Ä¶</li>
                <ul>
                    <li>Vamos inserir o valor 6.</li>
                </ul>
            </ul>
            <pre>
            <b>def</b> inserir(raiz,valor):
                novo = <b>no</b>(valor)
                <b>if</b> raiz == None:
                    raiz = novo
                <b>else</b>:
                    _ , <b>anc</b> = <b>buscar</b>(raiz,valor)
                    <b>conectar</b>(anc,novo)
            inserir(raiz,6)
            </pre>
            <img src="img/arvore-binaria16.png" alt="arvore-binaria16.png">
            <p></p>
            <img src="img/arvore-binaria18.png" alt="arvore-binaria18.png">
        </section>

        <section>
            <h2>√Årvore Bin√°ria (Classe).</h2>
            <ul>
                <li>Agora podemos criar a nossa classe ABB que conter√° todas as fun√ß√µes implementadas.</li>
                <ul>
                    <li>conectar(raiz,no)</li>
                    <li>buscar(raiz,valor)</li>
                    <li>inserir(raiz,valor)</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria18.png" alt="arvore-binaria18.png">
            <p></p>
            <img src="img/arvore-binaria19.png" alt="arvore-binaria19.png">
        </section>

        <section>
            <h2>Refer√™ncias</h2>
            <ul>
                <li>CORMEN, Thomas. Algoritmos: teoria e pr√°tica. Rio de Janeiro: GEN LTC, 2013. ISBN 9788595158092. Dispon√≠vel na Biblioteca Digital da UFMS.</li>
                <li>SZWARCFITER, Jayme Luiz; MARKENZON, Lilian. Estruturas de dados e seus algoritmos. 3. ed. Rio de Janeiro, RJ: LTC, 2010. ISBN 9788521629955. Dispon√≠vel na Biblioteca Digital da UFMS.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 28 de maio de 2024</p>
    </footer>
</body>
</html>
