<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 2 ‚Äì √Årvore Bin√°ria de Busca.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 2 ‚Äì √Årvore Bin√°ria de Busca.</h1>
        <h2>üí° Unidade 2 - Algoritmo de percurso e algoritmo de remo√ß√£o.</h2>
        <p>Prof¬∞ Especialista: Gedson Faria, Graziela Santos de Ara√∫jo e Jonathan de Andrade Silva.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>ESTRUTURA DE DADOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=3koM42vL6js&ab_channel=UNIVESP" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 2 - 
                Estrutura de Dados - Aula 18 - √Årvores bin√°rias de pesquisa - Parte 3.
                <i class="material-icons right"> send</i>
            </a>
            <p>Prof¬∞ ministrante: Norton T. Roman.</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Estrutura de Dados.</h3>
            <b>√Årvores bin√°rias de pesquisa.</b>
            <p>Remo√ß√£o de um elemento.</p>
        </section>

        <section>
            <h2>Remo√ß√£o de um elemento.</h2>
            <b>ABP ‚Äì Remo√ß√£o.</b>
            <ul>
                <li>Problemas na remo√ß√£o de um n√≥:</li>
                <ul>
                    <li>Temos que lidar com as sub√°rvores desse n√≥ A √°rvore resultante deve continuar sendo de busca.</li>
                    <ul>
                        <li>N√≥s da sub√°rvore da esquerda t√™m chave menor que a do n√≥ raiz.</li>
                        <li>N√≥s da sub√°rvore da direita t√™m chave maior que a do n√≥ raiz.</li>
                    </ul>
                </ul>
                <li>Como fazer?</li>
                <ul>
                    <li>Se o n√≥ a ser retirado possui no m√°ximo um descendente, substitua-o por este.</li>
                    <li>Se o n√≥ possuir 2 descendentes, substitu√≠mos o n√≥ a ser retirado pelo n√≥ mais √† direita da sub√°rvore da esquerda.</li>
                    <li>Alternativamente, substitu√≠mos o n√≥ a ser retirado pelo n√≥ mais √† esquerda da sub√°rvore da direita.</li>
                </ul>
                <li>Ou seja...</li>
                <ul>
                    <li>Para removermos o 15:</li>
                    <ul>
                        <li>Ou substitu√≠mos pelo 12 E 10 passa a ser filho de 8.</li>
                        <li>Ou substitu√≠mos pelo 20.</li>
                    </ul>
                </ul>
                <img src="img/arvore-binaria-remocao8.png" alt="arvore-binaria-remocao8.png">
            </ul>
            <ul>
                <li>Para remover, precisamos ent√£o saber:</li>
                <ul>
                    <li>O n√≥ a ser removido.</li>
                    <li>Seu pai.</li>
                    <li>O n√≥ substituto.</li>
                    <li>Seu pai.</li>
                </ul>
            </ul>
            <img src="img/arvore-binaria-remocao9.png" alt="arvore-binaria-remocao9.png">
            <p></p>
            <b>Vamos ent√£o fazer um m√©todo auxiliar:</b>
            <pre>
            /* Busca bin√°ria n√£o recursiva. Devolve o ponteiro do n√≥ buscado. Abastece pai com o ponteiro para o n√≥ pai deste /*

            PONT buscaNo (PONT raiz, TIPOCHAVE ch, PONT *pai) {
                PONT atual = raiz;
                *pai = NULL;

                while (atual) {
                    if (atual -> chave == ch) return (atual);
                    *pai atual;
                    if (ch < atual -> chave) atual = atual -> esq;
                    else atual = atual -> dir;
                }
                return (NULL);
            }
            </pre>
            <img src="img/arvore-binaria-remocao10.png" alt="arvore-binaria-remocao10.png">
            <pre>
            PONT removeNo (PONT raiz, TIPOCHAVE ch) {
                PONT pai, no, p, q;
                no = buscaNo (raiz,ch, &pai);
                if (no == NULL) return (raiz);
                <p>Tratamos o caso do n√≥ removido ter no m√°ximo um filho:</p>
                if (!no -> esq || !no - >dir ) {
                    if (!no -> esq) q = no -> dir;
                    else q = no -> esq;
                }
                <p>Ou de ter 2 filhos:</p>
                else {
                    P = no;
                    q = no -> esq;
                    while (q -> dir) {
                        P = q;
                        q = q -> dir;
                    }
                    <p>Al√©m de tratarmos do caso do pai do substituto ser ou n√£o o n√≥ removido:</p>
                    if (p != no) {
                        p -> dir = q -> esq;
                        q -> esq = no -> esq;
                    }
                    q -> dir = no -> dir;
                }
                <p>Do n√≥ removido ser a Raiz:</p>
                if (!pai) {
                    free(no);
                    return(q);
                }
                <p>Ou de n√£o ser a Raiz:</p>
                if (ch < pai -> chave) pai -> esq = q;
                else pai -> dir = q;
                free(no);
                return (raiz);
            }
            </pre>
            <img src="img/arvore-binaria-remocao11.png" alt="arvore-binaria-remocao11.png">
            <p></p>
            <b>ABP - Balanceamento.</b>
            <ul>
                <li>Podemos ter ent√£o a efici√™ncia de uma busca bin√°ria, caso a √°rvore esteja balanceada Com a vantagem de ser uma estrutura din√¢mica.</li>
            </ul>
            <img src="img/arvore-binaria-remocao12.png" alt="arvore-binaria-remocao12.png">
            <ul>
                <li>Ou voltamos √† busca sequencial, como em uma lista ligada S√≥ que usando mais mem√≥ria, pelo ponteiro extra.</li>
            </ul>
            <img src="img/arvore-binaria-balanceamento.png" alt="arvore-binaria-balanceamento.png">
            <ul>
                <li>A boa not√≠cia √© que se os elementos que comp√µem a √°rvore forem obtidos aleatoriamente, espera-se um desempenho apenas 39% pior do que a √°rvore completamente balanceada.</li>
                <li>Ou seja, a √°rvore em que as folhas aparecem no mesmo n√≠vel ou, no m√°ximo, em dois n√≠veis adjacentes.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 29 de maio de 2024</p>
    </footer>
</body>
</html>
