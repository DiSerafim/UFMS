<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 1 - Hash e Heap.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 1 - Hash e Heap.</h1>
        <h2>üí° Unidade 2 - Lista de Prioridades: Heap.</h2>
        <p>Prof¬∞ Especialista: Gedson Faria, Graziela Santos de Ara√∫jo e Jonathan de Andrade Silva.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>ESTRUTURA DE DADOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=GwA22pIu85I&ab_channel=AGEADUFMS" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 1 - 
                [UFMS Digital] Estrutura de Dados - M√≥dulo 1 - Unidade 2. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Prof¬∞ ministrante: Dr. Jonathan de Andrade Silva.</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Conceitos e Defini√ß√µes.</h3>
        </section>

        <section>
            <h2>Motiva√ß√£o</h2>
            <ul>
                <li>At√© agora vimos diferentes estruturas de dados com o objetivo de melhorar os custos de inser√ß√£o, remo√ß√£o ou busca de elementos em um conjunto;</li>
                <ul>
                    <li>Seja com Array (vetor), Lista, Pilha, Fila e Tabela de dispers√£o.</li>
                </ul>
                <li>Mesmo se conseguirmos o menor custo para buscar um elemento no conjunto, esse custo se manteria caso quis√©ssemos o <b>menor</b> ou o <b>maior</b> elemento do conjunto?</li>
                <ul>
                    <li>N√£o, precisar√≠amos <b>ordenar</b> o conjunto de dados, caro!</li>
                </ul>
                <li>Poder√≠amos ent√£o explorar a estrutura de dados <b>Fila de prioridades</b>.</li>
                <ul>
                    <li>Permite organizar/ordenar os elementos do conjunto por meio de seus valores de prioridades (ou chaves).</li>
                </ul>
                <li>Imagine em um posto de sa√∫de em que uma triagem √© feita para realizar os atendimentos dos pacientes.</li>
                <ul>
                    <li>A triagem determina uma prioridade ou chave (fita verde, amarela ou vermelha) para cada paciente;</li>
                    <li>Os atendimentos realizam uma busca pelo paciente de maior prioridade de atendimento (fita vermelha, primeiro).</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Heaps.</h2>
            <ul>
                <li>Heap pode ser visto como uma estrat√©gia para manter ordenado (mesmo ap√≥s inser√ß√£o ou remo√ß√£o) os elementos em uma <b>fila de prioridades ‚Äúordenado‚Äù</b> com custo menor que O(N), onde N √© o tamanho do conjunto;</li>
                <li>Podemos ter duas maneiras de ordenar as prioridades: do maior para o menor, ou vice e versa.</li>
                <ul>
                    <li><b>Max-Heap</b>: a prioridade est√° com os maiores valores.</li>
                    <li><b>Min-Heap</b>: a prioridade est√° com os menores valores.</li>
                </ul>
                <li>A ideia de organiza√ß√£o dos elementos na Heap, envolve organizar os elementos em uma estrutura conhecida como <b>√°rvore bin√°ria, ou alternativamente, heap bin√°ria (binary heap)</b>.</li>
                <ul>
                    <li>Cada elemento √© um n√≥ dessa estrutura de dados;</li>
                    <li>Por√©m, n√£o s√£o organizados (conectados) linearmente como √© feito em uma lista ou fila linear.</li>
                </ul>
                <li>A organiza√ß√£o segue um padr√£o de √°rvore bin√°ria em que um elemento A pode estar conectado a mais dois outros elementos desde que <b>ambos sejam menores ou maiores que A</b>.</li>
            </ul>
        </section>

        <section>
            <h2>Heap Bin√°ria vs Fila Ligada.</h2>
            <img src="img/heap-vs-fila.png" alt="heap-vs-fila.png">
        </section>

        <section>
            <h2>√Årvore Bin√°ria (defini√ß√µes).</h2>
            <img src="img/arvore-binaria.png" alt="arvore-binaria.png">
            <p></p>
            <img src="img/arvore-binaria1.png" alt="arvore-binaria1.png">
        </section>

        <section>
            <h2>Heap Bin√°ria (Array/Vetor).</h2>
            <ul>
                <li>Podemos tamb√©m representar essa √°rvore bin√°ria quase completa por meio de vetor/array, mas por que?</li>
                <ul>
                    <li>Lembra da Hash? Acesso direto, O(1);</li>
                </ul>
            </ul>
            <img src="img/heap-binaria.png" alt="heap-binaria.png">
            <p>Um n√≥ na posi√ß√£o i do vetor tem filhos nas posi√ß√µes FE=2*i+1 e FD=2*i + 2 e ancestral em (i-1)/2; Veja para o n√≥ B, i=1.</p>
            <img src="img/heap-binaria1.png" alt="heap-binaria1.png">
            <ul>
                <li>Agora que sabemos como encontrar os elementos da √°rvore no vetor, temos que definir algumas restri√ß√µes de ordem:</li>
                <ul>
                    <li>Prioridade do n√≥ ancestral <b>√© ‚â• que</b> dos filhos (<b>Max-Heap</b>);</li>
                    <img src="img/heap-binaria2.png" alt="heap-binaria2.png">
                    <li>Prioridade do n√≥ ancestral <b>√© ‚â§ que</b> dos filhos (<b>Min-Heap</b>);</li>
                    <img src="img/heap-binaria3.png" alt="heap-binaria3.png">
                </ul>
            </ul>
            <b>Heap Bin√°ria (Exemplos):</b>
            <p>Analise os 2 vetores abaixo e veja qual respeita as propriedades da Heap:</p>
            <img src="img/heap-binaria4.png" alt="heap-binaria4.png">
            <ul>
                <li>Quem √© o pai de 6?</li>
                <ul>
                    <li>anc(6) = (2-1)/2 = 1/2 = 0; H[0] = 9.</li>
                </ul>
                <li>Quem √© o filho esquerdo de 6?</li>
                <ul>
                    <li>FE(6) = 2*2+1 = 5; N√£o tem H[5]!</li>
                </ul>
                <li>Quem √© o filho direito de 9?</li>
                <ul>
                    <li>FD(9) = 2*0+2 = 2; H[2]=6.</li>
                </ul>
            </ul>
            <pre>
            F√≥rmula:
                anc(i) = ‚é£(i-1)/2‚é¶;
                FE(i)  = 2*i+1;
                FD(i)  = 2*i+2;
            </pre>
            <img src="img/heap-binaria5.png" alt="heap-binaria5.png">
            <p></p>
            <b>Heap Bin√°ria (Opera√ß√µes):</b>
            <p></p>
            <img src="img/heap-binaria6.png" alt="heap-binaria6.png">
            <ul>
                <li>Opera√ß√µes b√°sicas a serem realizadas na heap bin√°ria:</li>
                <ul>
                    <li>max(), extrairMax();</li>
                    <li>inserir(x,p): insere um elemento x com prioridade p;</li>
                </ul>
                <li>Qual dessas opera√ß√µes √© a mais trivial?</li>
            </ul>
            <b>Heap Bin√°ria (Inser√ß√£o - MaxHeap):</b>
            <ul>
                <li>Inser√ß√£o na Max-Heap.</li>
                <ul>
                    <li>Iniciando com a Heap vazia, inserimos primeiro valor na raiz (posi√ß√£o 0);</li>
                    <li>Os demais ser√£o inseridos no fim do vetor e verificando as viola√ß√µes at√© a raiz;</li>
                </ul>
            </ul>
            <img src="img/heap-binaria7.png" alt="heap-binaria7.png">
            <img src="img/heap-binaria8.png" alt="heap-binaria8.png">
            <ul>
                <li>Inser√ß√£o na Max-Heap.</li>
                <ul>
                    <li>Iniciando com a Heap vazia, inserimos o primeiro valor na raiz (posi√ß√£o 0);</li>
                    <li>Os demais ser√£o inseridos no fim do vetor e verificando as viola√ß√µes at√© a raiz;</li>
                </ul>
            </ul>
            <img src="img/heap-binaria9.png" alt="heap-binaria9.png">
            <img src="img/heap-binaria10.png" alt="heap-binaria10.png">
            <pre>
            anc(2) = (2-1)/2 = 0
            H[0] > H[2] ? N√£o
            trocar(H[2],H[0])
            </pre>
            <img src="img/heap-binaria12.png" alt="heap-binaria12.png">
            <img src="img/heap-binaria11.png" alt="heap-binaria11.png">
            <pre>
            anc(3) = (3-1)/2 = 1
            H[1] > H[3] ? N√£o
            trocar(H[3],H[1])
            </pre>
            <img src="img/heap-binaria13.png" alt="heap-binaria13.png">
            <img src="img/heap-binaria14.png" alt="heap-binaria14.png">
            <p></p>
            <img src="img/heap-binaria15.png" alt="heap-binaria15.png">
            <img src="img/heap-binaria16.png" alt="heap-binaria16.png">
            <pre>
            Inserir(H, novo):
                T = tamanho(H)
                SE FIM < T Ent√£o
                    H[FIM] = novo
                    VerificarInsercao(H,FIM)
                    FIM = FIM+1
                Sen√£o
                    ‚ÄúMaxHeap Cheia!‚Äù
            </pre>
            <img src="img/heap-binaria17.png" alt="heap-binaria17.png">
            <pre>
            VerificarInsercao(H, i):
                j = anc(i) = ‚é£(i-1)/2‚é¶
                Se i > 0 Ent√£o
                    Se H[i] > H[j] Ent√£o
                        trocar(H[i],H[j])
                        VerificarInsercao(H,j)
            </pre>
            <img src="img/heap-binaria19.png" alt="heap-binaria19.png">
            <ul>
                <li>Inser√ß√£o na Max-Heap.</li>
                <ul>
                    <li>Inserir em uma posi√ß√£o no vetor H tem custo O(1);</li>
                    <li>Verificar viola√ß√µes at√© a raiz tem custo proporcional a altura da √°rvore.</li>
                    <ul>
                        <li>Uma heap bin√°ria com N n√≥s tem ‚é£log2 (N)‚é¶+1 n√≠veis.</li>
                    </ul>
                    <li>Logo o custo da inser√ß√£o √© O(log2 (N)).</li>
                </ul>
            </ul>
            <p></p>
            <b>Heap Bin√°ria (Remo√ß√£o).</b>
            <ul>
                <li>ExtrairMax ou Remo√ß√£o na Max-Heap.</li>
                <ul>
                    <li>Retirar o elemento m√°ximo da raiz;</li>
                    <li>Preencher o espa√ßo vazio na raiz (posi√ß√£o 0) com o √∫ltimo elemento do vetor.</li>
                </ul>
            </ul>
            <img src="img/heap-binaria20.png" alt="heap-binaria20.png">
            <ul>
                <li>Verificando da raiz at√© as folhas as viola√ß√µes:</li>
                <ul>
                    <li>O maior entre: ancestral, FE e FD e trocar pelo ancestral;</li>
                    <li>Descer a √°rvore na dire√ß√£o do maior elemento trocado.</li>
                </ul>
            </ul>
            <img src="img/heap-binaria21.png" alt="heap-binaria21.png">
            <img src="img/heap-binaria22.png" alt="heap-binaria22.png">
            <pre>
            FE(1)=(2*1+1)=3
            FD(1)=(2*1+2)=4
            maior(H[FE],H[FD])=2
            H[1] > 2 ? Sim
            </pre>
            <img src="img/heap-binaria23.png" alt="heap-binaria23.png">
            <img src="img/heap-binaria24.png" alt="heap-binaria24.png">
            <pre>
            ExtrairMax(H):
                rem = H[0]
                H[0] = H[FIM-1]
                FIM = FIM-1
                    VerificarRemocao(H,0)
            </pre>
            <img src="img/heap-binaria25.png" alt="heap-binaria25.png">
            <pre>
            VerificarRemocao(H,i):                  EncMaior(H,i,fe,fd):
                fe = esq(i), fd = fe+1                  Se fe<T e H[fe] > H[i] Ent√£o
                pMaior = EncMaior(H,i,fe,fd)                pMaior=fe    
                Se pMaior ‚â† i Ent√£o                         Sen√£o pMaior=i
                    trocar(H[i], H[pMaior])             Se fd<T e H[fd] >
                    VerificarRemocao(H, pMaior)             H[pMaior] Ent√£o
                                                                pMaior=fd
                                                            retornar pMaior
            </pre>
            <img src="img/heap-binaria26.png" alt="heap-binaria26.png">
            <ul>
                <li>ExtrairMax ou Remo√ß√£o na Max-Heap.</li>
                <ul>
                    <li>Custo de retirar o maior elemento na raiz √© O(1);</li>
                    <li>Por√©m, descer a √°rvore e ir verificando as viola√ß√µes depende do n√∫mero de n√≠veis da √°rvore (como na inser√ß√£o);</li>
                    <li>Portanto, o custo da remo√ß√£o de um elemento √© O(log2 (N)).</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Refer√™ncias.</h2>
            <ul>
                <li>SZWARCFITER, Jayme Luiz; MARKENZON, Lilian. Estruturas de dados e seus algoritmos. 3. ed. Rio de Janeiro, RJ: LTC, 2010. ISBN 9788521629955.</li>
                <li>CORMEN, Thomas. Algoritmos: teoria e pr√°tica. Rio de Janeiro: GEN LTC, 2013. ISBN 9788595158092.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 25 de maio de 2024</p>
    </footer>
</body>
</html>
