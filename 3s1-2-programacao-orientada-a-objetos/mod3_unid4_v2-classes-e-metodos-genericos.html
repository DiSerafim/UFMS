<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 3 ‚Äì Pilares da Programa√ß√£o Orientada a Objetos.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 3 ‚Äì Pilares da Programa√ß√£o Orientada a Objetos.</h1>
        <h2>üí° Unidade 4 - Classes e M√©todos Gen√©ricos.</h2>
        <p>Professor Especialista: Anderson Vi√ßoso de Ara√∫jo.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMA√á√ÉO ORIENTADA A OBJETOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
        <a href="https://www.youtube.com/watch?v=ufJkkwdw1C4&ab_channel=UNIVESP" target="_blank" type="button" name="action" class="btn waves-effect waves-light">
                V√≠deo 2 - 
                [UFMS Digital] Programa√ß√£o Orientada a Objetos - M√≥dulo 3 - Unidade 4.
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Prof. Dr. Anderson Vi√ßoso de Ara√∫jo</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Classes e M√©todos Gen√©ricos.</h3>
            <p>ROTEIRO.</p>
            <ul>
                <li>Generics.</li>
                <li>Classes e M√©todos Gen√©ricos.</li>
                <li>Heran√ßa de Classes Gen√©ricas.</li>
                <li>Limita√ß√µes de Generics.</li>
            </ul>
        </section>

        <section>
            <h2>Generics.</h2>
            <ul>
                <li>Trata-se de um recurso bem parecido com os templates em C++.</li>
                <li>Este conceito permite que tipos (classes e interfaces) sejam par√¢metros na defini√ß√£o de classes, interfaces e m√©todos.</li>
                <li>Podemos reusar c√≥digo para diferentes tipos.</li>
                <li>Evita o uso de casting.</li>
            </ul>

            <ul>
                <li>Tipos Gen√©ricos.</li>
                <ul>
                    <li>√â uma classe ou interface parametrizada sobre tipos.</li>
                    <li>Em uma classe que n√£o usa Generics, qualquer objeto pode ser utilizado.</li>
                    <li>O problema √© que em tempo de compila√ß√£o n√£o √© poss√≠vel saber que tipo de objeto ser√° passado ou retornado.</li>
                </ul>
                <li>Para demonstrar como √© um c√≥digo Java sem Generics, vamos considerar o seguinte exemplo:</li>
                <ul>
                    <li>Tipos Gen√©ricos;</li>
                    <pre>
                    String result = (String) list.get(0);
                    System.out.println(result);
                    </pre>
                    <li>Veja que ao recuperar valores de uma lista era necess√°rio realizar o <b>cast</b> para um determinado tipo.</li>
                    <ul>
                        <li>Isso ocorre porque a interface <b>List</b> recebia um Object como par√¢metro em seu m√©todo add.</li>
                        <li>Lembre-se que em Java todos os tipos estendem Object.</li>
                    </ul>
                    <li>O c√≥digo acima compila corretamente. Agora vejamos o pr√≥ximo exemplo.</li>
                </ul>
            </ul>

            <ul>
                <li>Tipos Gen√©ricos;</li>
                <pre>
                    List list = new ArrayList();
                    list.add(1);
                    list.add("2");
                    list.add("3");
                    String result = (String) list.get(0);
                    System.out.println(result);
                </pre>
                <li>O que ocorre no c√≥digo acima?</li>
                <ul>
                    <li>N√£o √© poss√≠vel ter seguran√ßa de qual tipo ser√° retornado pela lista em tempo de compila√ß√£o e o erro somente ser√° percebido em tempo de execu√ß√£o, como o apresentado abaixo</li>
                </ul>
                <i>
                    out- Exception in thread "main" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
                </i>
            </ul>

            <ul>
                <li>Felizmente com uso de Generics, vamos economizar as escritas de c√≥digos e torn√°-los mais limpos e com possibilidade de reutiliza√ß√£o.</li>
                <li>A vantagem √© que o Generics vai servir como par√¢metro para a classe em quest√£o e assim podemos utilizar esta "vari√°vel" em todo o escopo da classe.</li>
            </ul>

            <ul>
                <li>Declara√ß√£o e Instancia√ß√£o de um tipo gen√©rico.</li>
                <ul>
                    <li>Deve especificar qual o tipo desejado.</li>
                    <li>√â parecido √† chamada de um m√©todo ou construtor, para qual passamos par√¢metros.</li>
                    <ul>
                        <li>Mas em Generics, o par√¢metro √© um tipo (classe ou interface).</li>
                    </ul>
                    <li>Tipos gen√©ricos n√£o podem receber tipos primitivos.</li>
                    <ul>
                        <li>Para isso Java possui classes que representam os tipos primitivos.</li>
                        <ul>
                            <li>int Integer.</li>
                            <li>double Double.</li>
                        </ul>
                    </ul>
                </ul>
                <pre>
                    Caixa Integer> integerCaixa = new Caixa Integer>();
                    integerCaixa.set(10);
                </pre>
            </ul>

            <p>Exemplo:</p>
            <li>Uma classe gen√©rica pode ter muitos par√¢metros.</li>
            <pre>
                public interface Par(K, V) {
                    public K getKey();
                    public V getValue();
                }

                public class ParaOrdenado(K, V) Par(K, V) {
                    implements private K key;
                    private V value;

                    public ParaOrdenado (K key, Vvalue) { this.key = key;
                            this.value = value;
                    }

                    public K getKey() { return key; }
                    public V getValue() { return value; }
                }
            </pre>

            <ul>
                <li>Conven√ß√µes.</li>
                <ul>
                    <li>Um par√¢metro de tipo pode ser especificado por qualquer palavra n√£o-chave.</li>
                    <li>Por√©m, por conven√ß√£o, tipos s√£o definidos com uma √∫nica letra.</li>
                    <ul>
                        <li>Element (Java Collections).</li>
                        <li>Key K.</li>
                        <li>N - Number.</li>
                        <li>T-Type.</li>
                        <li>V - Value.</li>
                    </ul>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Classes e M√©todos Gen√©ricos.</h2>
            <ul>
                <li>Para resolver o problema anterior, o que precisamos fazer?</li>
                <ul>
                    <li>Incluir um par√¢metro entre colchetes angulares logo ap√≥s o nome da classe</li>
                    <li>O tipo T pode ser qualquer tipo n√£o primitivo</li>
                </ul>
                <li>Ent√£o, o exemplo ficaria assim:</li>
            </ul>

            <p>Exemplo:</p>
            <pre>
                public class MinhaLista<T> {
                    private Object] elementos = new Object[0];

                    public T get(int indice) {
                        return (T) elementos[indice];
                    }

                    public void adiciona(T elemento) {
                        int posicao = elementos.length + 1;
                        elementos = Arrays.copyOf(elementos, posicao);
                        elementos[posicao] = elemento;
                    }
                }
            </pre>

            <ul>
                <li>No exemplo anterior, ao longo da classe o tipo T estar√° dispon√≠vel e poder√° ser utilizado na cria√ß√£o de:</li>
                <ul>
                    <li>Vari√°veis</li>
                    <li>Retorno de m√©todos (ex: get)</li>
                    <li>Em par√¢metros de m√©todos (ex: add)</li>
                </ul>
                <li>Isso faz com que MinhaLista possa ser utilizada com qualquer tipo, mas somente um tipo nos elementos, uma vez que a lista tenha sido instanciada</li>
            </ul>

            <p>Exemplo:</p>
            <pre>
                MinhaLista(String) lista = new MinhaLista<>();
                lista.add("1");
                lista.add("2");

                //N√£o precisa de cast, pois o compilador sabe que √© uma String
                String resultado = lista.get(0);
                System.out.println(resultado);
            </pre>

            <ul>
                <li>N√£o s√£o somente as classes e interfaces que possuem a flexibilidade dos Generics, tamb√©m podemos criar m√©todos gen√©ricos.</li>
                <li>M√©todos Gen√©ricos;</li>
                <ul>
                    <li>Conceito de Generics pode ser amplamante aplicado em m√©todos, sem que a classe seja gen√©rica (m√©todos est√°ticos, construtores, n√£o est√°ticos)</li>
                    <li>A lista de par√¢metros de tipo deve aparecer antes do tipo de retorno.</li>
                </ul>
            </ul>
            <pre>
                public class ParTeste {
                    public static (K, p1, V) boolean compare (Par(K, V)
                    p1,
                    Par(K, V) p2) {
                        return pl.getKey().equals(p2.getKey()) 
                        &&
                        pl.getvalue().equals(p2.getValue());
                    }
                }
            </pre>

            <ul>
                <li>M√©todos Gen√©ricos.</li>
                <li>Utiliza√ß√£o.</li>
            </ul>
            <pre>
                Par(Integer, String> p1 = new Par<>(1, "laranja");
                Par(Integer, String> p2 = new Par<>(2, "uva");
                boolean x = ParTeste. (Integer, String>compare (p1, p2);
            </pre>
            <pre>
                Par(Integer, String> p1 = new Par(1, "laranja");
                Par(Integer, String> p2 = new Par(2, "uva");
                boolean x = ParTeste. (Integer, String>compare (p1, p2);
            </pre>
            <pre>
                Par(Integer, String> pl = new Par(1, "laranja");
                Par(Integer, String> p2 = new Par(2, "uava");
                boolean x = ParUtil.compare (p1, p2);
            </pre>

            <ul>
                <li>√â importante frisar que quando utilizado em m√©todos, o tipo gen√©rico pertence ao escopo daquele m√©todo.</li>
                <li>N√£o √© poss√≠vel utilizar o tipo em outros m√©todos.</li>
                <ul>
                    <li>Se a classe tamb√©m √© gen√©rica e possui um identificador de tipo igual ao do m√©todo, o do m√©todo vai sobrescrever o da classe.</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Heran√ßa de Classes Gen√©ricas.</h2>
            <ul>
                <li>Quando criamos por exemplo, uma caixa de n√∫meros, qualquer tipo num√©rico poder√° ser armazenado.</li>
                <pre>
                    Caixa(Number> caixa = new Caixa(Number>();
                    caixa.add(new Integer(10)); // OK
                    caixa.add(new Double (10.1)); // ŒüŒö
                </pre>
                <li>No entanto, no m√©todo a seguir.</li>
                <pre>
                    public void caixaTest (Caixa<Number> n) {
                        /* ... */
                    }
                </pre>
                <li>Como n√£o h√° rela√ß√£o de heran√ßa entre as classes n√£o podemos passar Caixa<Integer> ou Caixa (Double>.</li>
            </ul>

            <ul>
                <li>√â poss√≠vel herdar ou implementar classes gen√©ricas.</li>
                <ul>
                    <li>Classe filha pode ou n√£o ser gen√©rica.</li>
                    <li>Toda a rela√ß√£o entre os tipos gen√©ricos da classe m√£e e da filha √© definida na declara√ß√£o de classe.</li>
                </ul>
                <li>Por exemplo:</li>
                <ul>
                    <li>ArrayList(E> implementa List(E>.</li>
                    <li>List(E> herda de Collection(E>.</li>
                </ul>
                <li>A rela√ß√£o de heran√ßa somente quando os tipos s√£o iguais.</li>
            </ul>

            <pre>
                Collection(String>
                    ü¢Å
                List(String>
                    ü¢Å
                ArrayList(String>
            </pre>
        </section>

        <section>
            <h2>Limita√ß√µes de Generics.</h2>
            <ul>
                <li>N√£o √© poss√≠vel instanciar um tipo gen√©rico utilizando tipos primitivos.</li>
                <pre>
                    Par(int, char> p = new Par<>(2, 'b'); // erro de compila√ß√£o
                    Par(Integer, Character> p = new Par<>(2, 'b'); // OK
                </pre>
                <li>N√£o √© poss√≠vel criar inst√¢ncias de par√¢metros gen√©ricos.</li>
                <pre>
                    public static <E> void append(List(E> list) {
                        E elem = new E(); // erro de compila√ß√£o
                        list.add(elem);
                    }
                </pre>
            </ul>
        </section>

        <section>
            <h2>Refer√™ncias:</h2>
            <p>1. Java Como Programar: Paul Deitel & Harvey Deitel - 10¬™ Edi√ß√£o.</p>
            <p>2. Java Como Programar: Paul Deitel & Harvey Deitel - 8¬™ Edi√ß√£o.</p>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 2 de maio de 2024</p>
    </footer>
</body>
</html>
