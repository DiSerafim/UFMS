<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PROGRAMAÇÃO ORIENTADA A OBJETOS-T01-2024-1.</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>PROGRAMAÇÃO ORIENTADA A OBJETOS-T01-2024-1.</h1>
        <h2>✅ [A3] Avaliação do Módulo 3 - Pilares da Programação Orientada a Objetos.</h2>
        <p>Professor Especialista: Anderson Viçoso de Araújo.</p>
        <p>Fecha: terça, 2 jul 2024, 23:59</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMAÇÃO ORIENTADA A OBJETOS.
                        <span class="status concluida">Concluído</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <ul>
                <li>Prof. Anderson Viçoso de Araújo.</li>
                <li>Iniciado em	sexta, 3 mai 2024, 20:24</li>
                <li>Estado	Finalizada</li>
                <li>Concluída em	sexta, 3 mai 2024, 21:23</li>
                <li>Tempo empregado	58 minutos 43 segundos</li>
                <li>Avaliar	10,00 de um máximo de 10,00(100%)</li>
            </ul>
        </section>
        <section id="conteudo">
            <h2>Questionário ✅ ❌</h2>

            <section class="question">
                <h3>Pergunta 1</h3>
                <p>Qual dos conceitos Herança, Abstração, Encapsulamento ou Polimorfismo é apresentado no código a seguir:</p>
                <pre>
                    public class Student{
                        private String name;
            
                        public String getName(){
                            return name;
                        }
            
                        public void setName(String name){
                            this.name = name
                        }
                    }
                </pre>

                <b class="answer">Resposta: Encapsulamento. ✅</b>
                <p>Resolução:</p>
                <li>Porque a classe Student possui um atributo name que é declarado como privado e acessado através de métodos públicos getName() e setName(). Dessa forma, o acesso direto ao atributo name é evitado, e a manipulação desse atributo é feita de forma controlada pelos métodos públicos, mantendo a integridade dos dados e seguindo o princípio de encapsulamento.</li>
            </section>

            <section class="question">
                <h3>Pergunta 2</h3>
                <p>Qual é a principal vantagem do uso de generics em Java?</p>
                <ul>
                    <li>a. Permite a definição de classes com atributos finais.</li>
                    <li>b. Permite a definição de classes com métodos estáticos.</li>
                    <li>c. Permite a criação de classes genéricas que podem ser reutilizadas com diferentes tipos de dados.</li>
                    <li>d. Permite a definição de classes com mais de um construtor.</li>
                </ul>

                <b class="answer">Resposta: c. ✅</b>
                <p>Resolução:</p>
                <li>Permitem que classes, interfaces e métodos possam ser parametrizados com tipos específicos, tornando-os mais flexíveis e reutilizáveis. Isso possibilita a criação de estruturas de dados e algoritmos que podem ser utilizados com diferentes tipos de dados, proporcionando maior segurança de tipo e reusabilidade do código.</li>
            </section>

            <section class="question">
                <h3>Pergunta 3</h3>
                <p>Sobre a classe definida a seguir, indique verdadeiro ou falso.</p>
                <pre>
                    public class MinhaClasse(T) {
                        private T objeto;                        
            
                        public MinhaClasse(T objeto) {
                            this.objeto = objeto;
                        }
            
                        public T getObjeto() {
                            return objeto;
                        }
                    }
                </pre>
                <p>Nesse exemplo, a classe MinhaClasse é definida com um tipo genérico T. O construtor recebe um objeto do tipo T e o armazena em um atributo da classe. O método getObjeto() retorna o objeto armazenado.</p>
                <p>Escolha uma opção: Verdadeiro ou Falso.</p>

                <b class="answer">Resposta: Verdadeiro. ✅</b>
                <p>Resolução:</p>
                <li>O tipo genérico T é definido. O construtor recebe um objeto do tipo T e o armazena em um atributo da classe. O método getObjeto() retorna o objeto armazenado, respeitando assim os conceitos de generics em Java.</li>
            </section>

            <section class="question">
                <h3>Pergunta 4</h3>
                <p>Dado o código a seguir:</p>
                <pre>
                    public class Superclass {
                        public void printMethod() {
                            System.out.println("Printed in Superclass.");
                        }
                    }
                    
                    public class Subclass extends Superclass {
                        public static void main(String[] args) {
                            Subclass s = new Subclass();
                            s.printMethod();
                        }
                    }
                </pre>
                <p>Selecione a opção que indica o que acontece após a execução do método main.</p>
                <p>Escolha uma opção:</p>
                <ul>
                    <li>a. O código não vai funcionar. Não é possível usar herança em Java.</li>
                    <li>b. O código não vai funcionar. Está chamando um método que não existe na classe.</li>
                    <li>c. Escreve uma linha em branco no console do usuário.</li>
                    <li>d. Escreve “Printed in Superclass.” no console do usuário.</li>
                </ul>
                
                <b class="answer">Resposta: d. ✅</b>

                <p>Resolução:</p>
                <li>Isso porque a classe Subclass estende a classe Superclass e, portanto, herda o método printMethod(). Quando o método main() é executado na classe Subclass, ele cria uma instância de Subclass e chama o método printMethod(). Como não há uma implementação diferente de printMethod() na classe Subclass, o método herdado da classe Superclass é executado, imprimindo "Printed in Superclass." no console.</li>
            </section>

            <section class="question">
                <h3>Pergunta 5</h3>
                <p>Qual dos conceitos Herança, Abstração, Encapsulamento ou Polimorfismo é apresentado no código a seguir:</p>
                <pre>
                    class Bike{
                        int speedlimit=90;
                    }
                    
                    class SuperBike extends Bike{
                        int speedlimit=150;
                
                        public static void main(String args[]){
                            Bike obj=new SuperBike ();
                            System.out.println(obj.speedlimit);
                        }
                    }
                </pre>

                <b class="answer">Resposta: Herança. ✅</b>

                <p>Resolução:</p>
                <p>Na classe SuperBike, ela herda da classe Bike, o que significa que ela adquire todas as propriedades e métodos da classe Bike. Portanto, quando você cria um objeto SuperBike e o atribui a uma referência do tipo Bike (Bike obj = new SuperBike();), você ainda pode acessar a variável speedlimit definida na classe Bike.</p>
                <p>Ao executar System.out.println(obj.speedlimit);, você está acessando a variável speedlimit da classe Bike, que tem o valor 90.</p>
            </section>

            <section class="question">
                <h3>Pergunta 6</h3>
                <p>Java não possui herança múltipla. Somente é possível estender uma única classe, mas pode-se implementar várias interfaces em uma mesma classe. Já para interfaces é possível ter herança múltipla, onde várias interfaces herdam os métodos de suas interfaces pais.</p>
                <p>Escolha uma opção: Verdadeiro ou Falso.</p>

                <b class="answer">Resposta: Verdadeiro. ✅</b>

                <p>Resolução:</p>
                <li>Em Java, uma classe só pode herdar de uma única classe pai, o que significa que a herança múltipla de classes não é permitida. No entanto, uma classe pode implementar várias interfaces, o que proporciona um mecanismo para alcançar comportamentos similares à herança múltipla, mas através da implementação de interfaces.</li>
            </section>

            <section class="question">
                <h3>Pergunta 7</h3>
                <p>Marque a alternativa que apresenta uma sequência de passos com alterações no código do exemplo abaixo capaz de transformá-lo em um código que use o recurso Generics em Java.</p>
                <pre>
                    #1  import java.util.ArrayList;
                    
                    #2  public class Main {
                    
                    #3      public static void main (String[] args) {
                    
                    #4           List nomes = new ArrayList();
                    
                    #5           nomes.add("João");
                    
                    #6           nomes.add("Pedro");
                    
                    #7           nomes.add("Carlos");
                    
                    #8           nomes.add("Paulo");
                    
                    #9
                    
                    #10         for (int i = 0; i < nomes.size(); i++) {
                    
                    #11              String nome = (String)nomes.get(i);
                    
                    #12    	         System.out.println(nome);
                    
                    #13         }
                    
                    #14     }
                    
                    #15 }
                </pre>
                <ul>
                    <li>a. Passo 1: substituir a linha de código #4 por:
                    ArrayList(String> nomes = new String();
                    Passo 2: substituir a linha de código #10 por:
                    for (nome: nomes) {
                    Passo 3:  Remover a linha de código #11</li>
                    
                    <li>b. Passo 1: substituir a linha de código #4 por:
                    ArrayList(String> nomes = new String();
                    Passo 2: substituir a linha de código #10 por:
                    for (String nomes: nome) {
                    Passo 3:  Remover a linha de código #11</li>
                    
                    <li>c. Passo 1: substituir a linha de código #4 por:
                    ArrayList(String> nomes = new ArrayList(String>();
                    Passo 2: substituir a linha de código #10 por:
                    for (String nome: nomes) {</li>
                    
                    <li>d. Passo 1: substituir a linha de código #4 por:
                    ArrayList(String> nomes = new ArrayList(String>();
                    Passo 2: substituir a linha de código #10 por:
                    for (String nome: nomes) {
                    Passo 3:  Remover a linha de código #11</li>
                    
                    <li>e. Passo 1: substituir a linha de código #4 por:
                    String nomes = new ArrayList(String>();
                    Passo 2:  Remover a linha de código #11</li>
                </ul>

                <b class="answer">Resposta: d. ✅</b>

                <p>Resolução:</p>
                <pre>
                Passo 1:
                ArrayList(String> nomes = new ArrayList(String>();
                <i>Modificar a declaração da lista nomes, utilizando
                generics para indicar que esta lista conterá apenas elementos do tipo String.
                Isso é feito ao especificar (String> dentro dos diamantes após ArrayList.</i>

                Passo 2:
                for (String nome: nomes) {
                <i>Alterando a estrutura do loop for para uma forma mais moderna e legível,
                conhecida como "for-each" loop.
                Essa estrutura nos permite iterar sobre os elementos de uma coleção sem 
                precisar de um contador de índice explícito.
                Neste caso, estamos percorrendo a lista nomes, onde cada nome é uma String.</i>

                Passo 3:
                Remover a linha de código #11
                <i>Removendo a linha String nome = (String)nomes.get(i);,
                que não é mais necessária após a alteração para o "for-each" loop no passo 2.
                Essa linha estava realizando um casting explícito para String,
                o que não é mais necessário ao usar generics,
                pois a lista nomes agora é declarada como uma lista de String.</i>
                </pre>
            </section>

            <section class="question">
                <h3>Pergunta 8</h3>
                <p>No conceito de classes genéricas, é possível definir um tipo curinga (?) em Java?</p>
                <ul>
                    <li>a. Somente se o tipo genérico for definido como abstract.</li>
                    <li>b. Não, não é possível.</li>
                    <li>c. Sim, é possível.</li>
                    <li>d. Somente se o tipo genérico for definido como final.</li>
                </ul>

                <b class="answer">Resposta: c. Sim, é possível. ✅</b>

                <p>Resolução:</p>
                <li>O tipo curinga é usado para representar um tipo desconhecido. Ele pode ser usado em várias situações, como em listas ou métodos, quando não se sabe ou não se importa com o tipo específico dos elementos. Isso permite uma maior flexibilidade no uso de classes genéricas.</li>
            </section>

            <section class="question">
                <h3>Pergunta 9</h3>
                <p>Associe as palavras a seguir com o seu respectivo significado.</p>
                <ul>
                    <li>Palavra reservada utilizada para redefinir o controle de fluxo permitindo executar diferentes blocos de código com base em diferentes valores de entrada em Java. (...)</li>

                    <li>Palavra reservada utilizada para definir uma interface em Java. (...)</li>

                    <li>Palavra reservada utilizada para continuar a iteração do laço para o próximo passo em Java. (...)</li>

                    <li>Palavra reservada utilizada para definir herança em Java. (...)</li>
                </ul>
                <p>Opções: Extends, Interface, Switch, Continue.</p>
                
                <b class="answer">Resposta: . ✅</b>
                <p>Resolução:</p>
                <ul>
                    <li>Palavra reservada utilizada para redefinir o controle de fluxo permitindo executar diferentes blocos de código com base em diferentes valores de entrada em Java. <b>Switch</b></li>
                    <li>Palavra reservada utilizada para definir uma interface em Java. <b>Interface</b></li>
                    <li>Palavra reservada utilizada para continuar a iteração do laço para o próximo passo em Java. <b>Continue</b></li>
                    <li>Palavra reservada utilizada para definir herança em Java. <b>Extends</b></li>
                </ul>
            </section>

            <section class="question">
                <h3>Pergunta 10</h3>
                <p>Dado o código a seguir:</p>
                <pre>
                    public class MyClass(T extends Number, C> {
                        T a;
                        C b;
           
                        public MyClass(T a, C b) {
                            this.a = a;
                            this.b = b;
                        }
           
                        void out() {
                            System.out.print(a);
                            System.out.print(b);
                        }
           
                        public static void main(String[] args) {
                            MyClass(Double, String> m = new MyClass<>(.1, "asdf");
                            m.out();
                       }
                    }
                </pre>
                <p>Marque a opção que indica a saída no console do usuário.</p>
                <p>Escolha uma opção:</p>
                <ul>
                    <li>a. 0.1asdf</li>
                    <li>b. asdf</li>
                    <li>c. Não sai nada. Código não executa.</li>
                    <li>d. 0.1</li>
                </ul>

                <b class="answer">Resposta: a. 0.1asdf. ✅</b>
            </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 3 de maio de 2024</p>
    </footer>
</body>
</html>
