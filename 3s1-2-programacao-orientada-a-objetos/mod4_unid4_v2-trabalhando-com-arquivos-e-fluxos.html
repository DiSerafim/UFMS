<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MÃ³dulo 3 â€“ Pilares da ProgramaÃ§Ã£o Orientada a Objetos.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>MÃ³dulo 4 â€“ Conceitos AvanÃ§ados.</h1>
        <h2>ðŸ’¡ Unidade 4 - Trabalhando com Arquivos e Fluxos.</h2>
        <p>Professor Especialista: Anderson ViÃ§oso de AraÃºjo.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMAÃ‡ÃƒO ORIENTADA A OBJETOS-T01-2024-1
                        <span class="status concluida">ConcluÃ­do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
        <a href="https://www.youtube.com/watch?v=9KxRnhyCUjA&ab_channel=UNIVESP" target="_blank" type="button" name="action" class="btn waves-effect waves-light">
                VÃ­deo 2 - 
                ProgramaÃ§Ã£o Orientada a Objetos â€“ Aula 13 â€“ Arquivos e serializaÃ§Ã£o. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Karina Valdivia Delgado.</p>
        </section>
        <section>
            <h2>ConteÃºdo</h2>
            <h3>Arquivos e serializaÃ§Ã£o.</h3>
            <p>Roteiro.</p>
            <ul>
                <li>Arquivos e fluxos.</li>
                <li>Fluxos de bytes.</li>
                <li>SerializaÃ§Ã£o de objetos.</li>
            </ul>
        </section>

        <section>
            <h2>IntroduÃ§Ã£o.</h2>
            <ul>
                <li>Programadores utilizam arquivos para armazenar dados a longo prazo.</li>
                <li>O Java vÃª cada arquivo como um fluxo sequencial. Existe um marcador de fim de arquivo.</li>
                <li>O termo fluxo se refere a uma fonte sequencial de dados, que por exemplo, sÃ£o lidos ou gravados em um arquivo.</li>
            </ul>
            <b>Arquivos binÃ¡rios.</b>
            <p>Criados com base em fluxo de bytes. Podem ser lidos por um programa que converte os dados em um formato legÃ­vel por humanos.</p>
            <b>Arquivos de texto.</b>
            <p>Criados com base em fluxo de caracteres. Podem ser lidos por editores de texto</p>
        </section>

        <section>
            <h2>Arquivos e fluxos.</h2>
            <p>Um programa Java abre um arquivo criando e associando um objeto ao fluxo de bytes ou caracteres. O construtor do objeto interage com o sistema operacional para abrir esse arquivo.</p>
            <p>O Java tambÃ©m pode associar fluxos a diferentes dispositivos.</p>
            <p>Exemplos de fluxos:</p>
            <ul>
                <li><b>System.in</b> objeto de fluxo de entrada padrÃ£o, permite inserir bytes a partir do teclado.</li>
                <li><b>System.out</b> objeto de fluxo de saÃ­da padrÃ£o, permite enviar caracteres para a tela.</li>
                <li><b>System.err</b> objeto de fluxo de erro padrÃ£o, permite enviar mensagens de erro para a tela.</li>
            </ul>
            <p>O processamento de arquivos Ã© realizado utilizando o pacote java.io que inclui classes de fluxo.</p>
            <p>Algumas classes de fluxo sÃ£o:</p>
            <ul>
                <li>FileInputStream.</li>
                <li>FileOutputStream.</li>
                <li>FileReader.</li>
                <li>FileWriter.</li>
            </ul>

            <b>Arquivos binÃ¡rios.</b>
            <ul>
                <li><b>FileInputStream</b>: para entrada baseada em bytes.</li>
                <li><b>FileOutputStream</b>: para saÃ­da baseada em bytes.</li>
            </ul>

            <b>Arquivos de texto.</b>
            <ul>
                <li><b>FileReader</b>: para entrada baseada em caracteres.</li>
                <li><b>FileWriter</b>: para saÃ­da baseada em caracteres.</li>
            </ul>

            <p>AlÃ©m das classes explicadas anteriormente temos em java.util:</p>
            <ul>
                <li><b>Scanner</b>: para entrada baseada em caracteres a partir do teclado ou de um arquivo.</li>
                <li><b>Formatter</b>: para saÃ­da baseada em caracteres na tela ou em arquivo.</li>
            </ul>
        </section>

        <section>
            <h2>Fluxos de bytes.</h2>
            <p>Todos os fluxos de bytes sÃ£o subclasses das classes abstratas <b>InputStream</b> ou <b>OutputStream</b>.</p>
            <p>SÃ£o utilizados para manipulaÃ§Ã£o de arquivos binÃ¡rios. Ex: som, imagem ou dados em geral.</p>
            <pre>
            InputStream
            â”œâ”€â”€ ByteArrayInputStream
            â”œâ”€â”€ FileInputStream
            â”œâ”€â”€ FilterInputStream
            â”‚   â”œâ”€â”€ BufferedInputStream
            â”‚   â”œâ”€â”€ DataInputStream
            â”‚   â”œâ”€â”€ LineNumberInputStream
            â”‚   â”œâ”€â”€ PushbackInputStream
            â”‚   â”œâ”€â”€ SequenceInputStream
            â”‚   â””â”€â”€ AudioInputStream
            â””â”€â”€ ObjectInputStream
            
            OutputStream
            â”œâ”€â”€ ByteArrayOutputStream
            â”œâ”€â”€ FileOutputStream
            â””â”€â”€ FilterOutputStream
                â”œâ”€â”€ BufferedOutputStream
                â”œâ”€â”€ DataOutputStream
                â””â”€â”€ PrintStream                
            </pre>
            <b>InputStream.</b>
            <ul>
                <li><b>ByteArrayInputStream</b>: Implementa um array de bytes como uma fonte de entrada de dados.</li>
                <li><b>FileInputStream</b>: LÃª dados de um arquivo como uma fonte de entrada de dados.</li>
                <li><b>FilterInputStream</b>: Classe base para filtragem de entrada de dados.</li>
                <ul>
                    <li><b>BufferedInputStream</b>: Fornece buffering para entrada de dados.</li>
                    <li><b>DataInputStream</b>: LÃª primitivos de dados em um formato de fluxo binÃ¡rio.</li>
                    <li><b>LineNumberInputStream</b>: Conta o nÃºmero de linhas lidas.</li>
                    <li><b>PushbackInputStream</b>: Permite retornar bytes lidos para o fluxo.</li>
                    <li><b>SequenceInputStream</b>: Concatena dois ou mais fluxos de entrada.</li>
                    <li><b>AudioInputStream</b>: Converte fluxos de Ã¡udio em outros tipos de fluxos.</li>
                </ul>
            </ul>
            <b>ObjectInputStream.</b>
            <ul>
                <li>LÃª objetos serializados de um fluxo de entrada.</li>
            </ul>

            <b>OutputStream.</b>
            <ul>
                <li><b>ByteArrayOutputStream</b>: Implementa um buffer em memÃ³ria como uma fonte de saÃ­da de dados.</li>
                <li><b>FileOutputStream</b>: Grava dados em um arquivo como uma fonte de saÃ­da de dados.</li>
                <li><b>FilterOutputStream</b>: Classe base para filtragem de saÃ­da de dados.</li>
                <ul>
                    <li><b>BufferedOutputStream</b>: Fornece buffering para saÃ­da de dados.</li>
                    <li><b>DataOutputStream</b>: Grava primitivos de dados em um formato de fluxo binÃ¡rio.</li>
                    <li><b>PrintStream</b>: Fornece funcionalidade de formataÃ§Ã£o de saÃ­da.</li>
                </ul>
            </ul>

            <b>Para ler um byte de um arquivo usamos FileInputStream.</b>
            <p>Primeiro criamos um fluxo de entrada. Ex:</p>
            <pre>
                InputStream fluxo = new FileInputStream ("arquivo.dat");
            </pre>
            <p>O argumento deverÃ¡ ser o nome do arquivo o qual pode incluir o caminho absoluto.</p>

            <b>Para escrever um byte em um arquivo usamos FileOutputStream.</b>
            <p>Primeiro criamos um fluxo de saÃ­da. Ex:</p>
            <pre>
                OutputStream fluxo = new FileOutputStream ("arquivo.dat");
            </pre>
        </section>

        <section>
            <h2>SerializaÃ§Ã£o de objetos.</h2>
            <p>Java permite ler e escrever objetos inteiros em arquivos.</p>
            <p>Ã‰ realizada com fluxos de bytes (arquivos binÃ¡rios).</p>
            <p>A classe deve implementar a interface Serializable.</p>

            <ul>
                <li>SerializaÃ§Ã£o Ã© um mecanismo para ler ou gravar um objeto inteiro a partir de um arquivo.</li>
                <li>Um objeto serializado Ã© um objeto representado como uma sequÃªncia de bytes que inclui:</li>
                <ul>
                    <li>- Dados do objeto</li>
                    <li>As informaÃ§Ãµes sobre o tipo do objeto</li>
                    <li>Os tipos dos dados armazenados no objeto.</li>
                </ul>
                <li>O objeto pode ser desserializado a partir do arquivo.</li>
            </ul>
            <p>As classes ObjectInputStream e ObjectOutputStream permitem que objetos sejam lidos ou gravados em um fluxo.</p>
            <p>Para usar a serializaÃ§Ã£o com arquivos inicializamos esses objetos de fluxo com objetos de fluxo que lÃªem e gravam bytes em arquivos: FileInputStream e FileOutputStream.</p>

            <b>Abertura do fluxo para leitura:</b>
            <pre>ObjectInputStream entrada = new ObjectInputStream(new FileInputStream("meusobjetos.ser"));</pre>

            <b>Abertura do fluxo para escrita:</b>
            <pre>ObjectOutputStream saida = new ObjectOutputStream(new FileOutputStream(â€œmeusobjetos.ser"));</pre>

            <b>Leitura de dados:</b>
            <pre>objeto = (Tipo) entrada.readObject();</pre>

            <b>Escrita de dados:</b>
            <pre>saida.writeObject(objeto);</pre>

            <b>Fechamento do arquivo:</b>
            <pre>
            entrada.close();
            saida.close();
            </pre>

            <p>Exemplo:</p>
            <pre>
            import java.io.Serializable;

            public class Cliente implements Serializable{
                private String cpf;
                private String nome;

                public Cliente (String cpf, String nome) {
                    this.cpf=cpf;
                    this.nome-nome;
                }

                public String toString(){
                    return " cpf: "+cpf+" nome: "+nome;
                }

                public String getCpf() {
                    return cpf;
                }

                public void setCpf(String cpf) {
                    this.cpf cpf;
                }

                public String getNome() {
                    return nome;
                }

                public void setNome (String nome) {
                    this.nome - nome;
                }
            }    
            </pre>
            <p>A interface Serializable Ã© uma interface de marcaÃ§Ã£o, nÃ£o tem nenhum mÃ©todo.</p>
            <p>A classe Ã© marcada para permitir que os objetos sejam serializÃ¡veis.</p>
            <p>Devemos verificar que cada atributo da classe tambÃ©m seja serializÃ¡vel.</p>

            <i>Cliente.java:</i>
            <pre>
            import java.io.*;

            public class Teste {
                public static void main(String[] args) {
                    Cliente cliente=new Cliente ("293894930", "Daniel");
                    FileOutputStream fluxo;

                    try {
                        fluxo = new FileOutputStream("cliente.ser");
                        ObjectOutputStream objarq=new ObjectOutputStream(fluxo); objarq.writeObject(cliente);

                        objarq.close();

                        System.out.println("Arquivo gravado");
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            </pre>
            <p>Se existir uma tentativa de leitura depois do final do arquivo, <b>readObject()</b> lanÃ§a uma <b>EOFException</b>.</p>
            <p>Se a classe do objeto sendo lido nÃ£o puder ser localizada, <b>readObject()</b> lanÃ§a uma exceÃ§Ã£o <b>ClassNotFoundException</b>.</p>
            <i>TesteLeitura.java:</i>
            <pre>
            import java.io.*;
            public class Teste {
                public static void main(String[] args) {
                    Cliente cliente;
                    FileInputStream fluxo;
                    ObjectInputStream objarq = null;
                    try {
                        fluxo new FileInputStream("cliente.ser");
                        objarq-new ObjectInputStream(fluxo);

                        while(true) {
                            cliente (Cliente) objarq.readObject();
                            System.out.println(cliente);
                        }
                    } catch (EOFException eofExc) {
                        System.out.println("Chegou no fim do arquivo");
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                    finally{}
                }
            }
            </pre>
            <p>Estruturas de dados do tipo Collection podem ser lidas ou escritas na sua totalidade sem necessidade de iteraÃ§Ã£o.</p>
            <pre>
            import java.io.*;
            public class TesteMapa {
                public static void main(String[] args) {
                    Map<Integer, String> mapa new TreeMap<Integer, String>(); mapa.put(455, "vermelho");
                    mapa.put(333, "branco"); mapa.put(678, "amarelo");
                    mapa.put(455, "azul");

                    try {
                        FileOutputStream fluxo0ut-new FileOutputStream("myFile.ser"); ObjectOutputStream fout-new ObjectOutputStream(fluxo0ut); fout.writeObject(mapa);
                        FileInputStream fluxoIn new FileInputStream("myFile.ser");
                        ObjectInputStream fIn=new ObjectInputStream(fluxoIn);
                        TreeMap<Integer, String> mapaNovo (TreeMap) fIn.read0bject(); fIn.close();

                        fout.close();

                        System.out.println(mapaNovo);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    } catch (IOException e) {
                        e.printStackTrace();
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
            </pre>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 7 de maio de 2024</p>
    </footer>
</body>
</html>
