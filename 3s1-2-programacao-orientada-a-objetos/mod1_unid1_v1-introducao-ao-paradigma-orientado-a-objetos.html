<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 1 - Fundamentos de Orienta√ß√£o a Objetos</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 1 - Fundamentos de Orienta√ß√£o a Objetos.</h1>
        <h2>üí° Unidade 1 - Introdu√ß√£o ao Paradigma Orientado a Objetos.</h2>
        <p>Professor Especialista: Anderson Vi√ßoso de Ara√∫jo.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMA√á√ÉO ORIENTADA A OBJETOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=bZJ_uDyNBcY&ab_channel=AGEADUFMS" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 1 - 
                [UFMS Digital] Programa√ß√£o Orientada a Objetos - M√≥dulo 1 - Unidade 1. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Prof. Dr. Anderson Vi√ßoso de Ara√∫jo</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>

            <h3>Introdu√ß√£o ao Paradigma Orientado a Objetos.</h3>
        </section>

        <section>
            <h2>Programa√ß√£o Orientada a Objetos (POO)</h2>
            <ul>
                <li>Criada por Alan Kay em 1969, atrav√©s da linguagem Smalltalk;</li>
                <li>Utiliza o conceito da cria√ß√£o de objetos e do relacionamento entre eles;</li>
                <li>Prov√™ caracter√≠sticas para o desenvolvimento r√°pido de software;</li>
                <li>√â o paradigma de programa√ß√£o mais utilizado atualmente.</li>
            </ul>
        </section>

        <section>
            <h2>Introdu√ß√£o √† POO</h2>
            <ul>
                <li>O mundo √† nossa volta n√£o est√° cheio de objetos?</li>
                <ul>
                    <li>Carros, constru√ß√µes, sapatos, pessoas, dispositivos...</li>
                </ul>
                <li>Cada um destes objetos t√™m a capacidade de executar a√ß√µes:</li>
                <ul>
                    <li>Acelerar, correr, ligar, enviar mensagem;</li>
                    <li>Uma a√ß√£o pode afetar outros objetos.</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Conceitos B√°sicos</h2>
            <p>Classes X Objetos</p>
            <b>Estruturada X Orientada a Objetos</b>

            <p>Programa√ß√£o Estruturada:</p>
            <ul>
                <li>O programa √© representado como uma estrutura l√≥gica;</li>
                <li>O fluxo de execu√ß√£o da programa√ß√£o √© dependente da estrutura do programa;</li>
                <li>O c√≥digo recebe mais import√¢ncia;</li>
                <li>Lidar com programas moderadamente complexos;</li>
                <li>Menos seguran√ßa de dados;</li>
                <li>Menos reutiliza√ß√£o de c√≥digo;</li>
                <li>Flexibilidade e abstra√ß√£o menos importantes;</li>
                <li>Esta √© uma abordagem de top-down.</li>
            </ul>
        
            <p>Programa√ß√£o Orientada a Objetos:</p>
            <ul>
                <li>O programa √© escrito como uma cole√ß√£o de objetos que se comunicam entre si;</li>
                <li>A entidade b√°sica √© objeto.</li>
                <ul>
                    <li>Cada c√°lculo √© realizado usando apenas os objetos;</li>
                </ul>
                <li>Os dados recebem mais import√¢ncia;</li>
                <li>Lida com programas muito complexos;</li>
                <li>Mais seguran√ßa de dados;</li>
                <li>Mais reutiliza√ß√£o;</li>
                <li>Flexibilidade e Abstra√ß√£o mais importantes;</li>
                <li>Esta √© a abordagem de bottom-up.</li>
            </ul>
        </section>

        <section>
            <h2>Mais sobre POO</h2>
            <ul>
                <li>Exemplos de linguagens de programa√ß√£o orientadas a objetos:</li>
                <ul>
                    <li>C++, C#, VB.NET, Java, Object Pascal, Objective-C, Python, SuperCollider, Ruby e Smalltalk.</li>
                </ul>
                <li>Desvantagens?</li>
                <ul>
                    <li>Pode se tornar muito complexa para problemas mais simples;</li>
                    <li>Modelagem pode ser complexa;</li>
                    <ul>
                        <li>Depende de experi√™ncia.</li>
                    </ul>
                    <li>√änfase grande em design e modelagem de software, em detrimento de outros aspectos (como a computa√ß√£o/algoritmos).;</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Regras de Neg√≥cio</h2>
            <p>Incluem pol√≠ticas da organiza√ß√£o, regulamentos do governo, padr√µes da ind√∫stria e algoritmos. N√£o s√£o requisitos de software pois existem independente de qualquer software espec√≠fico. Influenciam requisitos de neg√≥cio, de usu√°rio e funcionais, al√©m de atributos de qualidade.</p>
        </section>

        <section>
            <h2>Exemplo de Regras de Neg√≥cio</h2>
            <ul>
                <li>O cliente do banco pode sacar, no m√°ximo, R$1000,00 por dia de sua conta.</li>
                <li>Funcion√°rio tem direito a 30 dias de f√©rias ap√≥s 1 ano de trabalho.</li>
                <li>O professor deve lan√ßar a nota da prova em at√© 10 dias √∫teis.</li>
            </ul>
        </section>

        <section>
            <h2>Requisitos N√£o Funcionais</h2>
            <p>Uma propriedade ou caracter√≠stica que um sistema deve ter ou uma restri√ß√£o que deve respeitar. Atributos de qualidade descrevem as caracter√≠sticas do sistema em v√°rias dimens√µes, que s√£o importantes para usu√°rios e desenvolvedores.</p>
            <p>Exemplos incluem usabilidade, seguran√ßa, desempenho, portabilidade, compatibilidade, disponibilidade, interfaces externas e restri√ß√µes de design e implementa√ß√£o.</p>
        </section>

        <section>
            <h2>Engenharia de Requisitos</h2>
            <p>√â o processo de encontrar, analisar, documentar, verificar, validar e gerenciar requisitos e restri√ß√µes.</p>
        </section>

        <section>
            <h2>Fases da Engenharia de Requisitos</h2>
            <p><b>Desenvolvimento de Requisitos</b></p>
            <ul>
                <li>Elicita√ß√£o: explora os requisitos</li>
                <li>An√°lise: avalia os requisitos</li>
                <li>Especifica√ß√£o: documenta os requisitos</li>
                <li>Valida√ß√£o: confirma os requisitos</li>
            </ul>
            <p><b>Gerenciamento de Requisitos:</b> define acordo, avaliar impacto de mudan√ßas, rastreia requisitos, controla status‚Ä¶</p>
        </section>

        <section>
            <h2>Desenvolvimento: Elicita√ß√£o</h2>
            <p>Atividades relacionadas √† descoberta de requisitos: entrevistas, workshops, an√°lise de documentos, prototipagem, etc</p>
            <p>Principais atividades:</p>
            <ul>
                <li>Identificar classes de usu√°rios e outros stakeholders</li>
                <li>Entender os objetivos de neg√≥cio e tarefas dos usu√°rios</li>
                <li>Aprender sobre o ambiente onde o novo produto ser√° utilizado</li>
                <li>Trabalhar com membros de cada classe de usu√°rio para entender suas necessidades e expectativas</li>
            </ul>
        </section>

        <section>
            <h2>Desenvolvimento: An√°lise</h2>
            <p>Busca um entendimento mais preciso dos requisitos</p>
            <p>Principais atividades:</p>
            <ul>
                <li>Analisar a informa√ß√£o recebida do usu√°rio para diferenciar os diversos tipos de requisitos</li>
                <li>Decompor requisitos de alto-n√≠vel</li>
                <li>Derivar requisitos funcionais</li>
                <li>Entender os atributos de qualidade</li>
                <li>Alocar requisitos para componentes</li>
                <li>Negociar prioridades</li>
            </ul>
        </section>

        <section>
            <h2>Desenvolvimento: Especifica√ß√£o</h2>
            <p>Representa e armazena o conhecimento sobre os requisitos de modo persistente e organizado</p>
            <p>Principal atividade: traduzir as necessidades dos usu√°rios em requisitos escritos e diagramas</p>
        </section>

        <section>
            <h2>Desenvolvimento: Valida√ß√£o</h2>
            <p>Confirma que requisitos est√£o corretos e permitir√£o a constru√ß√£o de uma solu√ß√£o para satisfazer os objetivos de neg√≥cio</p>
            <p>Principais atividades:</p>
            <ul>
                <li>Revisar a documenta√ß√£o de requisitos para corrigir problemas antes que o desenvolvimento inicie</li>
                <li>Desenvolver testes e crit√©rios de aceita√ß√£o para confirmar que o produto satisfaz as necessidades dos usu√°rios e objetivos de neg√≥cio</li>
            </ul>
        </section>

        <section>
            <h2>Gerenciamento de Requisitos</h2>
            <p>Principais atividades:</p>
            <ul>
                <li>Definir a baseline dos requisitos (ponto que representa acordo entre stakeholders para release ou itera√ß√£o)</li>
                <li>Avaliar o impacto de mudan√ßas de requisitos</li>
                <li>Definir os relacionamentos e depend√™ncias</li>
                <li>Rastrear requisitos</li>
                <li>Controlar o status e mudan√ßas dos requisitos</li>
            </ul>
        </section>

        <section>
            <h2>Benef√≠cios da Engenharia de Requisitos</h2>
            <ul>
                <li>Os processos de requisitos enfatizam uma abordagem colaborativa do desenvolvimento de produtos.</li>
                <li>Um processo efetivo de mudan√ßas minimiza o impacto de altera√ß√µes nos requisitos.</li>
                <li>Requisitos documentados e claros facilitam os testes.</li>
            </ul>
            <p>Consequ√™ncias:</p>
            <ul>
                <li>Menos defeitos nos requisitos e no produto</li>
                <li>Menos retrabalho</li>
                <li>Desenvolvimento mais r√°pido</li>
                <li>Menos funcionalidades desnecess√°rias</li>
                <li>Menos erros de comunica√ß√£o</li>
                <li>Maior satisfa√ß√£o do cliente e do time de desenvolvimento</li>
                <li>Produtos fazem o esperado</li>
            </ul>
        </section>

        <section>
            <h2>Refer√™ncias</h2>
            <ul>
                <li>SOMMERVILLE, Ian; SAWYER, Pete. Requirements engineering: a good practice guide. 1997. England: John Willey & Son Ltd.</li>
                <li>WIEGERS, K. E.; BEATTY, J. Software Requirements. 3. Ed. Microsoft Press, 2013.</li>
            </ul>
        </section>

        <section>
            <h2>Licenciamento</h2>
            <p>Respeitadas as formas de cita√ß√£o formal de autores de acordo com as normas da ABNT NBR 6023 (2018), a n√£o ser que esteja indicado de outra forma, todo material desta apresenta√ß√£o est√° licenciado sob uma Licen√ßa Creative Commons - Atribui√ß√£o 4.0 Internacional.</p>
        </section>

        <section>
            <b>Slide:</b>
            <embed src="mod1-unid1-apresentacao.pdf" type="application/pdf" width="100%" height="600px" />
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 12 de mar√ßo de 2024</p>
    </footer>
</body>
</html>
