<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 3 ‚Äì Pilares da Programa√ß√£o Orientada a Objetos.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 4 ‚Äì Conceitos Avan√ßados.</h1>
        <h2>üí° Unidade 2 - Conjuntos e Mapas.</h2>
        <p>Professor Especialista: Anderson Vi√ßoso de Ara√∫jo.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMA√á√ÉO ORIENTADA A OBJETOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
        <a href="https://www.youtube.com/watch?v=Iudly4Lbw4o&ab_channel=AGEADUFMS" target="_blank" type="button" name="action" class="btn waves-effect waves-light">
                V√≠deo 1 - 
                [UFMS Digital] Programa√ß√£o Orientada a Objetos - M√≥dulo 4 - Unidade 2. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Prof. Dr. Anderson Vi√ßoso de Ara√∫jo</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Conjuntos e Mapas.</h3>
        </section>

        <section>
            <h2>A Interface Set.</h2>
            <ul>
                <li>Representa um agrupamento de elementos (de qualquer tipo);</li>
                <li>Mesmas caracter√≠sticas do Set ADT:</li>
                <ul>
                    <li>Similar ao conceito de conjuntos finitos na matem√°tica;</li>
                    <li>N√£o h√° no√ß√£o de ordem, posi√ß√£o dos elementos;</li>
                    <li>N√£o aceita elementos repetidos.</li>
                </ul>
                <li>Existem duas principais implementa√ß√µes:</li>
                <ul>
                    <li>HashSet: os elementos n√£o ficam ordenados (mais comum e mais r√°pido);</li>
                    <li>TreeSet: os elementos ficam ordenados, independente de como foram adicionados.</li>
                </ul>
            </ul>
            <b>Exemplo Set - HashSet.</b>
            <pre>
                public static void main(String[] args) {
                    Set set = new HashSet();    // Ou TreeSet, mesmo resultado
                    set.add("B");
                    set.add("1");
                    set.add("C");
                    set.add("E");
                    set.add("3");
                    set.add("A");
                    set.add("A");

                    for (Object obj : set){
                        String str = (String) obj;  // cast necess√°rio
                        System.out.print(str);
                    }
                }

                Sa√≠da: 1ABC3E
            </pre>
            <p>Como visto, esta classe n√£o permite duplicatas e n√£o mant√©m a sequ√™ncia de inser√ß√£o dos elementos. Teste com TreeSet!</p>
        </section>

        <section>
            <h2>A Interface Map.</h2>
            <ul>
                <li>Semelhante a um array, mas ao inv√©s de √≠ndices num√©ricos, usa objetos como chaves;</li>
                <li>Mesmas caracter√≠sticas do Map ADT:</li>
                <ul>
                    <li>Cada entrada possui:</li>
                    <ul>
                        <li>Uma chave/key (de qualquer tipo): serve para indexar os elementos, ou seja, serve para achar um elemento rapidamente. Deve ser compar√°vel;</li>
                        <li>Um valor/value (de qualquer tipo): o valor armazenado na fila e associado a chave.</li>
                    </ul>
                    <li>As chaves s√£o √∫nicas, por√©m os valores podem ser duplicados:</li>
                    <ul>
                        <li>Caso haja uma repeti√ß√£o de chave, o elemento antigo √© sobreposto pelo novo.</li>
                    </ul>
                    <li>Tamb√©m chamado de dictionary.</li>
                </ul>
                <li>Principais classes que implementam a interface:</li>
                <ul>
                    <li>HashMap: n√£o sincronizado e n√£o ordenado, aceita null como chave (mais comum);</li>
                    <li>HashTable: igual ao HashMap, por√©m sincronizado e n√£o aceita null como chave;</li>
                    <li>TreeMap: n√£o sincronizado mas √© ordenado.</li>
                </ul>
            </ul>
            <b>Exemplo Map (HashMap).</b>
            <pre>
                public static void main(String[] args) {
                    Map nomes = new HashMap();
                    nomes.put("Jo√£o", 35);
                    nomes.put("Jos√©", 22);
                    nomes.put("Maria", 76);
                    nomes.put("Bianca", 18);

                    System.out.println("Quantidade: "+nomes.size());

                    int idadeMaria = (int)nomes.get("Maria");   // cast necess√°rio
                    System.out.print(idadeMaria);
                }
            </pre>
            <ul>
                <li>Inicialmente ser√° impresso 4, que √© o tamanho total do Mapa criado;</li>
                <li>Em seguida, ser√° impresso: ‚Äú76‚Äù que √© o objeto (int) correspondente √† chave ‚ÄúMaria‚Äù;</li>
                <li>N√£o d√° pra usar o foreach direto (s√≥ se for na Entry).</li>
            </ul>
        </section>

        <section>
            <h2>Collections + Generics.</h2>
            <ul>
                <li>√â poss√≠vel definir uma cole√ß√£o ou mapa restrito a um tipo espec√≠fico de objeto:</li>
                <ul>
                    <li>A partir do Java 1.5.</li>
                </ul>
                <li>Pode ser chamado de polimorfismo param√©trico;</li>
                <li>Desta forma, fica invi√°vel adicionar elementos √† cole√ß√£o que n√£o sejam do tipo especificado;</li>
                <li>Com isso, temos:</li>
                <ul>
                    <li>Maior n√≠vel de seguran√ßa;</li>
                    <li>Evitar o cast.</li>
                </ul>
            </ul>

            <b>Collections + Generics - Cria√ß√£o.</b>
            <ul>
                <li>Ao ser criado, informamos o tipo do elemento que pode ser armazenado na cole√ß√£o:</li>
                <ul>
                    <li>Set(String> nomes = new HashSet(String>();</li>
                    <li>List(Cliente> clientes = new ArrayList<>();</li>
                </ul>
                <li>Isto porque a cole√ß√£o √© implementada com tipos gen√©ricos, onde o tipo √© determinado no momento da execu√ß√£o (Runtime).                </li>
            </ul>

            <b>Collections + Generics - Exemplo:</b>
            <pre>
            List(ContaCorrente> contas = new ArrayList(ContaCorrente>();
                contas.add(c1);
                contas.add(c3);
                contas.add(c2);

                for(int i = 0; i < contas.size(); i++) {
                    ContaCorrente cc = contas.get(i); // sem cast!
                    System.out.println(cc.getSaldo());
                }
            </pre>
            <p>N√£o h√° necessidade do cast, por exemplo:</p>
            <i>ContaCorrente cc = (ContaCorrente) contas.get(i);</i>
        </section>

        <section>
            <h2>For-each + Generics.</h2>
            <ul>
                <li>Exemplo:</li>
                <ul>
                    <li>for (String nome: listaNomes) { ... }</li>
                    <ul>
                        <li>Onde listaNomes √© uma cole√ß√£o do tipo String:</li>
                        <ul>
                            <i>Collection(String> listaNomes</i>
                        </ul>
                    </ul>
                </ul>
                <li>N√£o d√° pra usar direto para Maps</li>
                <ul>
                    <li>Precisa pegar para as chaves (keySet) ou valores (values)</li>
                </ul>
            </ul>

            <b>Exemplo - ForEach.</b>
            <pre>
            public static void main(String[] args) {
                Collection<String> nomes = new ArrayList<>();   // LinkedList,...
                System.out.println("Qtd elementos: "+nomes.size());

                for (String str: nomes) {
                    System.out.println(str);
                }
            }
            </pre>
            <ul>
                <li>Ser√° impresso o tamanho total da estrutura do conjunto criado.</li>
                <li>Em seguida, por meio do foreach, ser√£o impressos todos os elementos (Strings) que pertencem √† cole√ß√£o criada.</li>
                <ul>
                    <li>Que pode ser qualquer cole√ß√£o de objetos.</li>
                </ul>
            </ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 4 de maio de 2024</p>
    </footer>
</body>
</html>
