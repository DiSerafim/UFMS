<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MÃ³dulo 3 â€“ Pilares da ProgramaÃ§Ã£o Orientada a Objetos.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>MÃ³dulo 4 â€“ Conceitos AvanÃ§ados.</h1>
        <h2>ðŸ’¡ Unidade 1 - ColeÃ§Ãµes.</h2>
        <p>Professor Especialista: Anderson ViÃ§oso de AraÃºjo.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMAÃ‡ÃƒO ORIENTADA A OBJETOS-T01-2024-1
                        <span class="status concluida">ConcluÃ­do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
        <a href="https://www.youtube.com/watch?v=MqWv-6A7ksk&ab_channel=AGEADUFMS" target="_blank" type="button" name="action" class="btn waves-effect waves-light">
                VÃ­deo 1 - 
                [UFMS Digital] ProgramaÃ§Ã£o Orientada a Objetos - MÃ³dulo 4 - Unidade 1. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Prof. Dr. Anderson ViÃ§oso de AraÃºjo</p>
        </section>
        <section>
            <h2>ConteÃºdo</h2>

            <h3>ColeÃ§Ãµes.</h3>
        </section>

        <section>
            <h2>IntroduÃ§Ã£o.</h2>
            <ul>
                <li>Java tem uma API especÃ­fica para manipulaÃ§Ã£o de objetos, denominada <b>Collections</b>;</li>
                <li>Ã‰ uma soluÃ§Ã£o flexÃ­vel para armazenar objetos, o que facilita bastante a vida do desenvolvedor;</li>
                <li>A API Collections provÃª interfaces e classes para coleÃ§Ãµes;</li>
                <li>Numa coleÃ§Ã£o, a quantidade armazenada de objetos nÃ£o Ã© fixa, como ocorre com arrays;</li>
                <ul>
                    <li>Seu tamanho pode aumentar automaticamente conforme sÃ£o adicionados mais elementos.</li>
                </ul>
                <li>Por meio destas coleÃ§Ãµes, Ã© possÃ­vel representar diferentes tipos de estruturas, como: listas, pilhas, filas, conjuntos e mapas.</li>
            </ul>
        </section>

        <section>
            <h2>Hierarquia das Collections (interfaces).</h2>
            <pre>
            Object
            â””â”€â”€ AbstractCollection
                â”œâ”€â”€ Collection
                â”‚   â”œâ”€â”€ AbstractSet
                â”‚   â”‚   â”œâ”€â”€ Set
                â”‚   â”‚   â”‚   â”œâ”€â”€ HashSet
                â”‚   â”‚   â”‚   â””â”€â”€ TreeSet
                â”‚   â”‚   â””â”€â”€ SortedSet
                â”‚   â”œâ”€â”€ AbstractList
                â”‚   â”‚   â”œâ”€â”€ List
                â”‚   â”‚   â”‚   â”œâ”€â”€ LinkedList
                â”‚   â”‚   â”‚   â”œâ”€â”€ ArrayList
                â”‚   â”‚   â”‚   â””â”€â”€ Vector
                â”‚   â”‚   â””â”€â”€ AbstractSequentialList
                â”‚   â””â”€â”€ Queue
                â””â”€â”€ List                
            </pre>

            <ul>
                <li><b>Object</b>: Classe base de todas as classes em Java.</li>
                <li><b>AbstractCollection</b>: Classe abstrata que fornece uma implementaÃ§Ã£o base para a interface Collection.</li>
                <li><b>Collection</b>: Interface que representa uma coleÃ§Ã£o de objetos, que pode ser uma lista, conjunto ou fila.</li>
                <li><b>AbstractSet</b>: Classe abstrata que fornece uma implementaÃ§Ã£o base para a interface Set.</li>
                <li><b>Set</b>: Interface que representa um conjunto de elementos Ãºnicos, sem duplicatas.</li>
                <li><b>HashSet</b>: ImplementaÃ§Ã£o de Set que armazena elementos em uma tabela de dispersÃ£o, sem garantia de ordem.</li>
                <li><b>TreeSet</b>: ImplementaÃ§Ã£o de Set que mantÃ©m os elementos ordenados, geralmente em ordem natural ou usando um comparador personalizado.</li>
                <li><b>SortedSet</b>: Interface que estende Set e mantÃ©m os elementos ordenados.</li>
                <li><b>AbstractList</b>: Classe abstrata que fornece uma implementaÃ§Ã£o base para a interface List.</li>
                <li><b>List</b>: Interface que representa uma lista ordenada de elementos.</li>
                <li><b>LinkedList</b>: ImplementaÃ§Ã£o de List que armazena os elementos em uma lista encadeada.</li>
                <li><b>ArrayList</b>: ImplementaÃ§Ã£o de List que armazena os elementos em um array redimensionÃ¡vel.</li>
                <li><b>Vector</b>: ImplementaÃ§Ã£o legada de List, semelhante a ArrayList, mas sincronizada.</li>
                <li><b>AbstractSequentialList</b>: Classe abstrata que fornece uma implementaÃ§Ã£o base para listas sequenciais.</li>
                <li><b>Queue</b>: Interface que representa uma fila, seguindo o princÃ­pio FIFO (First-In-First-Out).</li>
            </ul>
        </section>

        <section>
            <h2>Hierarquia dos Maps (interfaces).</h2>
            <pre>
            Object
            â””â”€â”€ AbstractMap
                â”œâ”€â”€ Map
                â”‚   â”œâ”€â”€ HashMap
                â”‚   â”œâ”€â”€ HashTable
                â”‚   â”œâ”€â”€ TreeMap
                â”‚   â””â”€â”€ SortedMap
                â”‚       â””â”€â”€ N/A
            </pre>
            <p>Observe que um Map nÃ£o Ã© uma Collection (hierarquia - heranÃ§a).</p>
            <ul>
                <li><b>Object</b> Ã© a classe base de todas as classes em Java.</li>
                <li><b>AbstractMap</b> fornece uma implementaÃ§Ã£o base para a interface Map.</li>
                <li><b>Map</b> Ã© a interface que mapeia chaves para valores Ãºnicos.</li>
                <li><b>HashMap</b> Ã© uma implementaÃ§Ã£o de Map que usa uma tabela de dispersÃ£o para armazenar os pares chave-valor.</li>
                <li><b>HashTable</b> Ã© uma implementaÃ§Ã£o legada de Map, semelhante ao HashMap, mas sincronizada.</li>
                <li><b>TreeMap</b> Ã© uma implementaÃ§Ã£o de Map que mantÃ©m as chaves em ordem natural ou por meio de um comparador personalizado.</li>
                <li><b>SortedMap</b> Ã© uma subinterface de Map que mantÃ©m as chaves ordenadas e oferece mÃ©todos adicionais de consulta baseados em ordenaÃ§Ã£o.</li>
            </ul>
        </section>

        <section>
            <h2>A Interface List.</h2>
            <ul>
                <li>Uma lista Ã© uma coleÃ§Ã£o de elementos arrumados em uma ordem linear:</li>
                <ul>
                    <li>Ã‰ uma coleÃ§Ã£o em ordem (algumas vezes chamada de sequÃªncia);</li>
                    <li>Em geral, na ordem em que foram adicionados Ã  lista;</li>
                </ul>
                <li>Isto Ã©, cada elemento tem um antecessor (exceto o primeiro) e um sucessor (exceto o Ãºltimo);</li>
                <li>Normalmente implementada como Array ou Lista Encadeada.</li>
            </ul>
        </section>

        <section>
            <h2>List - ImplementaÃ§Ãµes.</h2>
            <ul>
                <li><b>ArrayList:</b></li>
                <ul>
                    <li>A implementaÃ§Ã£o mais utilizada da interface;</li>
                    <li>Ã‰ implementada sobre um vetor:</li>
                    <ul>
                        <li>Logo tem as vantagens e desvantagens associadas: acesso randÃ´mico, portanto Ã© rÃ¡pida para pesquisa.</li>
                    </ul>
                    <li>NÃ£o Ã© sincronizado, isto Ã© nÃ£o tem seguranÃ§a para programaÃ§Ã£o concorrente (threads)</li>
                </ul>
                <li><b>Vector</b>: Ideal para acesso randÃ´mico, porÃ©m Ã© sincronizado, logo, Ã© mais lento.</li>
                <li><b>LinkedList</b>: ideal para acesso sequencial:</li>
                <ul>
                    <li>Ã‰ implementada sobre uma lista ligada. Logo tem as vantagens e desvantagens associadas;</li>
                    <li>NÃ£o Ã© sincronizado, logo, nÃ£o suporta threads.</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Exemplo List (ArrayList).</h2>
            <pre>
            public static void main(String[] args) {
                List list = new ArrayList();
                list.add(9);
                list.add(new Integer(8));
                list.add(new Integer(10));
                list.add(new Integer(6) + 3);
                list.add(7);

                for (int i = 0; i < list.size(); i++) {
                    int x = (int)list.get(i);//cast necessÃ¡rio
                    System.out.println(x);
                }
            }
            </pre>
            <i>SaÃ­da: 9 8 10 9 7</i>
        </section>

        <section>
            <h2>For-each.</h2>
            <pre>
                <b>Sintaxe</b>:
                <i> for (Tipo nomeVar: ColeÃ§Ã£o)</i>
                <b>Exemplo</b>:
                <i> for (Object obj: colecao_ou_vetor)</i>

                DÃ¡ pra usar com Generics!
                Funciona para arrays tambÃ©m (jÃ¡ vimos isso!)
            </pre>
        </section>

        <section>
            <h2>Exemplo 2 List (ArrayList).</h2>
            <pre>
                public static void main(String[] args) {
                    List list = <b>new</b> LinkedList();
                    list.add(1);
                    list.add("Strings");
                    list.add("Teste");
                    list.add(<b>new</b> Integer("1"));
                    list.add(<b>new</b> ArrayList());
                    System.out.println(list.get(2));

                    for (Object obj: list) {
                        System.out.println(obj);
                    }
                }
            </pre>
            <i>SaÃ­da: Teste 1 Strings Teste 1 []</i>
            <p>NÃ£o dÃ¡ pra usar o for usando o Ã­ndice (por exemplo, i), pois nÃ£o existe a noÃ§Ã£o de posiÃ§Ã£o.</p>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 4 de maio de 2024</p>
    </footer>
</body>
</html>
