<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 3 ‚Äì Pilares da Programa√ß√£o Orientada a Objetos.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 3 ‚Äì Pilares da Programa√ß√£o Orientada a Objetos.</h1>
        <h2>üí° Unidade 3 - Interfaces e Abstra√ß√£o.</h2>
        <p>Professor Especialista: Anderson Vi√ßoso de Ara√∫jo.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>PROGRAMA√á√ÉO ORIENTADA A OBJETOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
        <a href="https://www.youtube.com/watch?v=cfEXV6fedt8&ab_channel=AGEADUFMS" target="_blank" type="button" name="action" class="btn waves-effect waves-light">
                V√≠deo 1 - 
                [UFMS Digital] Programa√ß√£o Orientada a Objetos - M√≥dulo 3 - Unidade 3. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Prof. Dr. Anderson Vi√ßoso de Ara√∫jo</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>

            <h3>Interfaces e Abstra√ß√£o.</h3>
        </section>

        <section>
            <h2>Abstra√ß√£o.</h2>
            <ul>
                <li>Habilidade de expor comportamentos essenciais de uma classe enquanto se esconde os detalhes de implementa√ß√£o.</li>
                <li>Por que usar abstra√ß√£o?</li>
                <ul>
                    <li>Reduz a complexidade do c√≥digo.</li>
                    <li>Organiza o projeto/c√≥digo.</li>
                </ul>
                <li>Tornar uma classe abstrata (ou seja, uma classe que n√£o pode ser instanciada) ou implementar uma interface.</li>
                <li><i>Abstraction is more about ‚ÄòWhat‚Äò a class can do. [Idea]</i>.</li>
                <li>A defini√ß√£o da abstra√ß√£o ocorre durante a fase de planejamento/defini√ß√£o das classes.</li>
                <li>Se uma classe √© abstrata e n√£o pode ser instanciada, a classe n√£o tem muita utilidade, a n√£o ser que seja estendida (heran√ßa).</li>
                <li>A classe pai cont√©m a funcionalidade comum de uma cole√ß√£o de classes filhas (como na heran√ßa simples) mas n√£o tem fun√ß√£o sozinha.</li>
                <li>Na classe abstrata √© poss√≠vel ter m√©todos normais e ter m√©todos abstratos tamb√©m.</li>
                <li>Modificadores de classe:</li>
                <ul>
                    <li><b>final</b>: nenhuma classe pode estender (herdar) da classe final</li>
                    <li><b>abstract</b>: a classe n√£o pode ser instanciada</li>
                </ul>
                <li>Modificador de m√©todo:</li>
                <ul>
                    <li><b>abstract</b>: o m√©todo n√£o vai ser instanciado na classe abstrata, mas deve ser obrigatoriamente implementado em suas subclasses concretas</li>
                </ul>
            </ul>
            <p>Exemplo - Abstra√ß√£o</p>
            <pre>
                abstract class Instrumento {
                    protected double peso;
                    public abstract void tocar();
                }

                public final class Guitarra extends InstrumentoDeCordas {
                    public Guitarra () {
                        peso = 3.5;
                        numeroDeCordas = 6;
                    }

                    public void tocar(){
                        //...
                    }
                }

                abstract class InstrumentoDeCordas extends Instrumento {
                    protected int numeroDeCordas;
                }
            </pre>

            <p>Exemplo da aula anterior.</p>
            <pre>
                abstract class Animal {
                    public abstract void makeNoise();
                }

                class Dog extends Animal{
                    public void makeNoise(){
                        System.out.println("Bark");
                    }
                }

                class Cat extends Animal{
                    public void makeNoise(){
                        System.out.println("Meawoo");
                    }
                }
            </pre>
        </section>

        <section>
            <h2>Interface.</h2>
            <ul>
                
                <li>√â uma lista de declara√ß√£o de m√©todos e constantes:</li>
                <ul>
                    <li>N√£o implementa os m√©todos, s√≥ declara*;</li>
                    <li>N√£o tem construtores.</li>
                </ul>
                <li>N√£o √© uma classe;</li>
                <li>N√£o pode ser instanciada.</li>
                <li><i>* Menos em Java 8 (m√©todos default)</i></li>
                <li>Interfaces representam ‚Äúservi√ßos de suporte‚Äù para as classes que as implementam (contrato):</li>
                <ul>
                    <li>Em geral, est√£o associados com capacidades a serem dadas √†s classes;</li>
                    <li>Ou a um papel que a classe pode representar;</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Membros Internos de uma Interface.</h2>
            <ul>
                <li>Todos os atributos s√£o implicitamente public, static e final:</li>
                <ul>
                    <li>Ou seja, CONSTANTES!</li>
                </ul>
                <li>M√©todos de uma interface s√£o implicitamente public e abstract;</li>
                <ul>
                    <li>J√° que s√£o abstract, n√£o podem ser marcados como final.</li>
                </ul>
                <li>Os m√©todos de interfaces n√£o podem ser static*;</li>
                <li>Uma interface SOMENTE pode estender interfaces (uma ou mais interfaces diferentes):</li>
                <ul>
                    <li>Heran√ßa M√∫ltipla!</li>
                    <li>Separadas por uma v√≠rgula na defini√ß√£o.</li>
                </ul>
                <li><li>*Menos em Java 8 (m√©todos static em interfaces)</li></li>
            </ul>
                <b>Membros Internos - Exemplo:</b>
                <p>O que √© declarado:</p>
                <pre>
                    interface MinhaInterface{
                        int x = 10;

                        void metodo1();
                        void metodo2(String str);
                    }
                </pre>
                
                <p>O que √© visto pelo compilador:</p>
                <pre>
                    interface MinhaInterface{
                        public static final int x = 10;
                        public abstract void metodo1();
                        public abstract void metodo2(String str);
                    }
                </pre>
        </section>

        <section>
            <h2>Exemplo de Uso de Interface - ADTs (Abstract Data Types).</h2>
            <ul>
               <li>Pilha, Fila, String, Grafo‚Ä¶</li>
               <li>Um ADT pode ser implementado de diversas maneiras:</li>
               <li>Uma pilha, por exemplo, pode ser implementada em um vetor ou em uma lista ligada.</li>
               <li>Para ser uma pilha, o que a classe obrigatoriamente tem que ter?</li>
            </ul>
            <b>Exemplo:</b>
            <pre>
                interface Pilha{
                    int pop();
                    void push(int x);
                    int size();
                    int top();
                }
            </pre>
            <ul>
                <li>A classe <b>PilhaVetor</b> compromete-se a ser tratada como Pilha, sendo obrigada a ter os m√©todos necess√°rios, definidos no ‚Äúcontrato‚Äù;</li>
                <li>Faz sentido algum desses m√©todos da interface n√£o serem p√∫blicos?</li>
            </ul>
            <pre>
                class PilhaVetor implements Pilha{
                    int[] v = new int[100];
                    public int pop(){
                
                    }
                
                    public void push(int x){
                
                    }
                    ...
                }
            </pre>
        </section>

        <section>
            <h2>Declara√ß√£o de Interfaces.</h2>
            <ul>
                <li>A interface especifica quais opera√ß√µes podem ser realizadas, mas n√£o especifica como essas opera√ß√µes s√£o realizadas.</li>
                <li>Os modificadores de acesso de interfaces s√£o os mesmos que de classes:</li>
                <ul>
                    <li>public</li>
                    <li>package-private (sem modificador)</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Implementando M√©todos da Interface.</h2>
            <ul>
                <li>Uma classe que implementa uma interface deve implementar todos os m√©todos definidos por aquela interface;</li>
                <li>Se um ou mais m√©todos n√£o for implementado, o compilador Java gerar√° um erro;</li>
                <li>Subclasses (filhos) automaticamente implementam todas as interfaces que as suas superclasses (pais) implementam.</li>
            </ul>
        </section>

        <section>
            <h2>Subinterfaces.</h2>
            <ul>
                <li>Interfaces podem ser estendidas (heran√ßa):</li>
                <ul>
                    <li>A hierarquia de uma interface √© independente da hierarquia da classe;</li>
                    <li>A interface que estende outra interface herda todos os seus m√©todos.</li>
                    <ul>
                        <li>A classe concreta que implementa uma interface filha de outra, tem que obrigatoriamente implementar os m√©todos de ambas as interfaces;</li>
                    </ul>
                </ul>
            </ul>
            <b>Subinterfaces - Exemplo 1:</b>
            <pre>
                interface Readable{
                    byte readByte();
                }

                interface Writable{
                    void writeByte(byte b);
                }
                                                <i>Heran√ßa m√∫ltipla.</i>
                                                  ü°ø  ü¢Ü
                interface ReadWrite extends Readable, Writable {
                    void seek(int position);
                }
            </pre>

            <b>Subinterfaces - Exemplo 1 (2).</b>
            <pre>
                class File implements ReadWrite{
                    byte readByte(){...}

                    void writeByte(byte b){...}

                    void seek(int position){...}
                }
            </pre>

            <b>Exemplo 2:</b>
            <pre>
                public interface Drawable{
                    //implicitly public,
                    //static and final
                    double PI = 3.1415;
                
                    //implicitly abstract
                    //and public
                    void draw();
                }
            </pre>
            <pre>
                public class Circle implements Drawable{
                    private double radius;

                    public Circle(double r){
                        radius = r;
                    }

                    public void draw() {
                        System.out.println("Drawing a circle");
                    }

                    public double getArea(){
                        return PI * radius * radius;
                    }

                    public double getRadius(){
                        return radius;
                    }
                }
            </pre>

            <b>Exemplo 2 (2):</b>
            <pre>
                public class Rectangle implements Drawable{
                    private double width;
                    private double height;
                
                    public Rectangle(double w, double h){
                        width = w;
                        height = h;
                    }

                    public void draw() {
                        System.out.println("Drawing a rectangle");
                    }

                    public double getArea() {
                        return height * width;
                    }
                }
            </pre>

            <b>Exemplo 3:</b>
            <pre>
                abstract class Shape {
                    private String color = "blue";
                    public abstract double getArea();

                    public void setColor(String color){
                        this.color = color;
                    }

                    public String getColor() {
                        return this.color;
                    }
                }
            </pre>
            <pre>
                public class Rectangle extends Shape implements Drawable{
                    private double width;
                    private double height;

                    public Rectangle(double w, double h){
                        width = w;
                        height = h;
                    }

                    public void draw() {
                        System.out.println("Drawing Rectangle");
                    }

                    public double getArea() {
                        return height * width;
                    }
                }                
            </pre>
        </section>

        <section>
            <h2>Vantagens.</h2>
            <ul>
                <li>Permite um maior controle sobre como os objetos s√£o usados;</li>
                <li>Aumenta o desacoplamento entre os c√≥digos:</li>
                <li>F√°cil de alterar o c√≥digo sem ‚Äúquebrar‚Äù.</li>
                <li>Aumenta a reusabilidade de c√≥digo:</li>
                <li>YES!.</li>
            </ul>

            <table>
                <tr>
                    <th>Abstract class</th>
                    <th>Interface</th>
                </tr>
                <tr>
                    <td>1) A classe abstrata pode ter m√©todos abstratos e n√£o abstratos.</td>
                    <td>A interface pode ter apenas m√©todos abstratos.</td>
                </tr>
                <tr>
                    <td>2) A classe abstrata n√£o suporta heran√ßa m√∫ltipla.</td>
                    <td>A interface suporta heran√ßa m√∫ltipla.</td>
                </tr>
                <tr>
                    <td>3) A classe abstrata pode ter vari√°veis ‚Äã‚Äãfinais, n√£o finais, est√°ticas e n√£o est√°ticas.</td>
                    <td>A interface possui apenas vari√°veis ‚Äã‚Äãest√°ticas e finais.</td>
                </tr>
                <tr>
                    <td>4) A classe abstrata pode ter m√©todos est√°ticos, m√©todo principal e construtor.</td>
                    <td>A interface n√£o pode ter m√©todos est√°ticos, m√©todo principal ou construtor.</td>
                </tr>
                <tr>
                    <td>5) A classe abstrata pode fornecer a implementa√ß√£o da interface.</td>
                    <td>A interface n√£o pode fornecer a implementa√ß√£o de uma classe abstrata.</td>
                </tr>
                <tr>
                    <td>6) A palavra-chave abstract √© usada para declarar a classe abstrata.</td>
                    <td>A palavra-chave interface √© usada para declarar a interface.</td>
                </tr>
                <tr>
                    <td>7) 0-100% de abstra√ß√£o</td>
                    <td>100% de abstra√ß√£o</td>
                </tr>
                <tr>
                    <td>
                <pre>
                8) Example:
                public abstract class Shape{
                    public abstract void draw();
                }
                </pre>
                    </td>
                    <td>
                <pre>
                Example:
                public interface Drawable{
                    void draw();
                }
                </pre>
                    </td>
                </tr>
            </table>
            
            
             
            
            
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 30 de abril de 2024</p>
    </footer>
</body>
</html>
