<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 2 ‚Äì Interface Hardware/Software.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 2 ‚Äì Interface Hardware/Software.</h1>
        <h2>üí° Unidade 2 - Tradu√ß√£o de linguagem de alto n√≠vel para instru√ß√µes de m√°quina.</h2>
        <p>Prof¬™ Especialista: Dra. Nahri Moreano.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>SISTEMAS COMPUTACIONAIS.
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=K4EY0AbTOZ4&ab_channel=EmilioFrancesquini" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 1 - 
                2.1 - Arquitetura de Computadores - Instru√ß√µes: A Linguagem do Computador. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Prof¬∞ ministrante: Em√≠lio Francesquini.</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Arquitetura de Computadores.</h3>
        </section>

        <section>
            <h2>Conjunto de instru√ß√µes.</h2>
            <ul>
                <li>O <b>Conjunto de Instru√ß√µes</b> (en: instruction set) √© o conjunto das instru√ß√µes de um computador.</li>
                <li>Diferentes computadores t√™m diferentes conjuntos de instru√ß√µes.</li>
                <ul>
                    <li>Mas todos tem muitos aspectos em comum!</li>
                </ul>
                <li>Os primeiros computadores tinham conjuntos de instru√ß√µes bem limitados</li>
                <ul>
                    <li>Isto simplificava a implementa√ß√£o do hardware do computador</li>
                </ul>
                <li>Muitos computadores modernos continuam a ter conjuntos de instru√ß√µes simples</li>
            </ul>
        </section>

        <section>
            <h2>O Conjunto de Instru√ß√µes MIPS.</h2>
            <ul>
                <li>√â o conjunto com o qual mais trabalharemos at√© o fim da disciplina</li>
                <li>√â um computador (Stanford MIPS) que √© comercializado pela empresa MIPS Technologies (www.mips.com).</li>
                <ul>
                    <li>Atualmente muito usado em roteadores, NAS, impressoras, c√¢meras...</li>
                    <li>Tamb√©m foi o processador usado no Nintendo 64, Playstation 1 e 2, e PSP</li>
                    <li>E tamb√©m nos carros Tesla e Volvo</li>
                </ul>
                <li>Por que o MIPS?</li>
                <ul>
                    <li>Ele representa o desing t√≠pico das arquiteturas mais modernas como ARMv7 e ARMv8</li>
                    <li>O livro cont√©m uma p√°gina com muitos outros detalhes sobre o MIPS</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Instru√ß√µes aritm√©ticas.</h2>
            <ul>
                <li>Vamos come√ßar com uma das opera√ß√µes mais utilizadas: adi√ß√£o</li>
                <li>As instru√ß√µes em MIPS prezam pela regularidade</li>
                <ul>
                    <li>Quase todas trabalham com 3 operandos</li>
                </ul>
                <li><b>Princ√≠pio de Design 1</b>: Simplicidade favorece regularidade</li>
                <ul>
                    <li>Regularidade torna a implementa√ß√£o do hardware mais simples</li>
                    <li>Simplicidade permite um desempenho superior a um custo inferior</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Soma - add.</h2>
            <p>add soma dois n√∫meros em registradores e armazena o resultado em um terceiro registador</p>
            <pre>
            add a, b, c  # a = b + c
            </pre>
            <p>sub funciona de maneira equivalente para a subtra√ß√£o</p>
        </section>

        <section>
            <h2>Soma - Exemplo.</h2>
            <p>O seguinte c√≥digo em C...</p>
            <pre>
            f = (g + h) (i + j);
            </pre>
            <p>se transforma em:</p>
            <pre>
            add to, g, h  # temp to = g + h
            add t1, i, j  # temp t1 = i + j
            sub f, to, t1 # f = to t1
            </pre>
            <p>Esse exemplo ainda √© fict√≠cio: n√£o existem registradores f, g, h, i,...</p>
        </section>

        <section>
            <h2>Operandos em registradores</h2>
            <ul>
                <li>Instru√ß√µes aritm√©ticas operam apenas em valores j√° contidos nos registradores</li>
                <li>MIPS tem 32 registradores de 32 bits cada um</li>
                <ul>
                    <li>Registradores s√£o r√°pidos e s√£o usados para dados acessados frequentemente</li>
                    <li></li>S√£o numerados de 0 a 31</li>
                    <li>Uma <b>palavra</b> (en: word) no MIPS s√£o 32 bits</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Registradores.</h2>
            <ul>
                <li>Nomenclatura</li>
                <ul>
                    <li>$to, $t1, $t9 utilizados para vari√°veis tempor√°rias</li>
                    <li>$50, $s1, $s7 utilizadas para vari√°veis salvas</li>
                </ul>
                <li><b>Princ√≠pio de Design 2</b>: menor √© mais r√°pido</li>
                <ul>
                    <li>Considere o tempo de acesso para milhares de posi√ß√µes e o tempo de acesso para apenas algumas dezenas</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Exemplo: operandos em registradores.</h2>
            <pre>
            f = (g + h) - (i + j);

                f armazenado em $s0
                g armazenado em $s1
                h armazenado em $s2
                i armazenado em $s3
                j armazenado em $s4
        
            C√≥digo MIPS:
                add $t0, $s1, $s2
                add $t1, $s3, $s4
                sub $s0, $to, $t1
            </pre>
        </section>

        <section>
            <h2>Operadores na mem√≥ria</h2>
            <ul>
                <li>A mem√≥ria principal pode ser usado para dados maiores ou compostos</li>
                <ul>
                    <li>Structs, arrays, estruturas din√¢micas (listas ligadas, √°rvores, ...)</li>
                </ul>
                <li>Contudo, opera√ß√µes aritm√©ticas trabalham apenas nos registradores</li>
                <li>Precisamos ent√£o ferramentas para carregar os valores da mem√≥ria nos registradores</li>
                <ul>
                    <li>Opera√ß√£o conhecida como <b>load</b></li>
                </ul>
                <li>Tamb√©m precisamos uma maneira de levar os valores dos registradores de volta √† mem√≥ria</li>
                <ul>
                    <li>Capacidade e quantidade de registradores s√£o limitadas!</li>
                    <li>Opera√ß√£o conhecida como <b>store</b></li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Mais alguns detalhes....</h2>
            <ul>
                <li>A mem√≥ria √© <b>endere√ßada</b> (en: addressed) por bytes</li>
                <ul>
                    <li>Cada endere√ßo identifica um byte de 8 bits</li>
                </ul>
                <li>Palavras s√£o <b>alinhadas</b> na mem√≥ria</li>
                <ul>
                    <li>Logo, como cada palavra tem 32 bits, cada endere√ßo √© um m√∫ltiplo de 4</li>
                </ul>
                <li>MIPS √© <b>Big Endian</b></li>
                <ul>
                    <li>Isso significa que o byte mais significativo fica localizado no menor endere√ßo da palavra</li>
                    <li>Em contrapartida, arquiteturas <b>litte endian</b> armazenam o byte menos significativo no menor endere√ßo</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Exemplo 1: Lendo operadores na mem√≥ria.</h2>
            <pre>
            O MIPS oferece a instru√ß√£o lw (load word) que recebe:
                registrador destino
                deslocamento (en:offset)
                registrador base (en: base register)
            
                g = h + A[8];

                Onde g est√° em $s1, h em $s2, e endere√ßo base de A em $s3
                C√≥digo MIPS:
                lw $t0, 32($s3)  # Aten√ß√£o ao deslocamento
                add $s1, $s2, $t0
            </pre>
        </section>

        <section>
            <h2>Exemplo 2: Escrevendo operadores na mem√≥ria.</h2>
            <p>De maneira semelhante, temos a instru√ß√£o <b>sw</b> (store word) que armazena o valor do segundo operando no registrador apontado pelo primeiro.</p>
            <pre>
                1 A[12] h+ A[8];
                
            Onde h em $s2, e endere√ßo base de A em $s3
            C√≥digo MIPS:
                lw $t0, 32($s3)  # Aten√ß√£o ao deslocamento
                add $t1, $s2, $to
                sw $t1, 48($s3)  # Aten√ß√£o ao deslocamento
            </pre>
        </section>

        <section>
            <h2>Registradores vs. mem√≥ria.</h2>
            <ul>
                <li>Registradores s√£o de acesso mais r√°pido que a mem√≥ria</li>
                <li>Operar na mem√≥ria exige o uso de loads e stores</li>
                <ul>
                    <li>Mais instru√ß√µes precisam ser executadas</li>
                </ul>
                <li>Compiladores se esfor√ßam para usar os registradores o m√°ximo poss√≠vel</li>
                <ul>
                    <li>Eles apenas <b>vazam</b> (en: spill) os registradores contendo as vari√°veis menos frequentemente utilizadas</li>
                    <li>O estudo da otimiza√ß√£o do uso de registradores √© important√≠ssimo e foi por muitos anos t√≥pico de muitas pesquisas</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>Operadores Imediatos.</h2>
            <ul>
                <li>Operandos imediatos (en: immediate operands) s√£o √∫teis pois, frequentemente, trabalhamos com constantes no nosso c√≥digo.</li>
                <ul>
                    <li>Pense <b>i++, x = 0</b>, ...</li>
                    <li>Otimizando casos comuns podemos ganhar simplicidade e desempenho</li>
                </ul>
                <li>A opera√ß√£o <b>add</b> tem uma vers√£o com operando imediato chamada <b>addi</b></li>
                <pre>addi $s3, $s3, 4</pre>
                <li>N√£o temos a vers√£o com imediatos de <b>sub</b>, mas <b>addi</b> aceita valores negativos. Ent√£o:</li>
                <pre>addi $s2, $s1, -1</pre>
            </ul>
        </section>

        <section>
            <h2>Princ√≠pio de design.</h2>
            <ul>
                <li><b>Princ√≠pio de Design 3</b>: Torne os casos comuns r√°pidos</li>
                <ul>
                    <li>Constantes s√£o comuns e o operando imediato evita uma instru√ß√£o de load</li>
                </ul>
            </ul>
        </section>

        <section>
            <h2>A constante Zero.</h2>
            <ul>
                <li>A constante <b>zero</b> √© t√£o importante e comum que o MIPS reserva um registrador que sempre contem este valor: <b>$zero</b></li>
                <ul>
                    <li>Esse registrador n√£o pode ser sobrescrito</li>
                </ul>
                <li>√â muito √∫til para efetuar opera√ß√µes muito comuns, por exemplo, copiar um valor entre um registrador e outro</li>
                <ul>
                    <li>Tradicionalmente essa opera√ß√£o √© chamada de move ainda que ela n√£o elimine o valor original</li>
                </ul>
                <pre>add $t2, $s1, $zero</pre>
            </ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 11 de jun de 2024</p>
    </footer>
</body>
</html>
