<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>M√≥dulo 3 ‚Äì SGBDs Relacionais.</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>M√≥dulo 3 ‚Äì SGBDs Relacionais.</h1>
        <h2>üí° Unidade 2 - Processamento de transa√ß√µes e controle de concorr√™ncia.</h2>
        <p>Professor Especialista: Vanessa Borges.</p>
    </header>
    <main>
        <section id="disciplinas">
            <h2>Disciplinas</h2>
            <p></p>
            <ul>
                <li>
                    <p>BANCO DE DADOS-T01-2024-1
                        <span class="status concluida">Conclu√≠do</span>
                    </p>
                </li>
            </ul>
        </section>
        <section id="materiais">
            <h2>Materiais</h2>
            <a href="https://www.youtube.com/watch?v=5IlGUIvRu3k&ab_channel=UNIVESP" class="btn waves-effect waves-light" target="_blank" type="button" name="action">
                V√≠deo 3 - 
                Bancos de Dados - Aula 26 - Controle de concorr√™ncia ‚Äì Parte II. 
                <i class="material-icons right"> send</i>
            </a>
            <p>Professor ministrante: Sarajane Marques Peres.</p>
        </section>
        <section>
            <h2>Conte√∫do</h2>
            <h3>Controle de concorr√™ncia.</h3>
        </section>

        <section>
            <h2>Controle de concorr√™ncia.</h2>
            <ul>
                <li>Um sistema est√° em estado de <b>deadlock</b> se h√° um conjunto de transa√ß√µes tal que cada transa√ß√£o neste conjunto est√° esperando outra transa√ß√£o tamb√©m contida nele.</li>
                <ul>
                    <li>Seja um conjunto de transa√ß√µes <b>{T1, T2, ..., Tn}</b>.</li>
                    <ul>
                        <li>T1 est√° esperando um item de dado mantido por <b>T2</b>.</li>
                        <li><b>Tn-1</b> est√° esperando um item de dado mantido por <b>Tn</b>.</li>
                    </ul>
                </ul>
                <li>√â preciso dispor de procedimentos de manuseio do deadlock.</li>
            </ul>
            <p>Existem <b>dois m√©todos principais</b> para tratamento de deadlock.</p>
            <p><b>Preven√ß√£o de deadlock</b>: garante que o sistema nunca entrar√° em tal situa√ß√£o. Mais utilizado se a probabilidade do sistema entrar em deadlock for alta.</p>
            <p><b>Detec√ß√£o e recupera√ß√£o de deadlock</b>: permite que o sistema entre em um estado de deadlock e ent√£o o remove desse estado recuperando-o.</p>
        </section>

        <section>
            <h2>Preven√ß√£o: Abordagem 1.</h2>
            <ul>
                <li>Obriga que cada transa√ß√£o bloqueie todos os itens de dados antes de sua execu√ß√£o.</li>
                <li>Ou todos os itens s√£o bloqueados de uma s√≥ vez (a transa√ß√£o consegue todos os bloqueios), ou nenhum o ser√°.</li>
            </ul>
            <p>Esse esquema reduz a concorr√™ncia.</p>
        </section>

        <section>
            <h2>Preven√ß√£o: Abordagem 2.</h2>
            <ul>
                <li>Quando uma transa√ß√£o T2 solicita o bloqueio que est√° sendo mantido pela transa√ß√£o T1, o bloqueio concedido a T1 pode ser revisto por meio do rollback de T1 e concedido a T2.</li>
                <li>Para controlar a preemp√ß√£o, considera-se um √∫nico timestamp para cada transa√ß√£o. Eles s√£o usados para decidir se a transa√ß√£o esperar√° pelo bloqueio ou ser√° desfeita.</li>
                <li>Se uma transa√ß√£o for desfeita, ela manter√° seu timestamp original quando for reiniciada.</li>
            </ul>
            <b>Esperar- morrer:</b>
            <ul>
                <li>Quando uma transa√ß√£o Ti solicita um item de dado mantido por Tj:</li>
                <ul>
                    <li>se Ti√© mais velha (timestamp menor) do que Tj, Ti espera;</li>
                    <li>se Ti√© mais nova (timestamp malor) do que TJ, Ti √© desfeita (morrer).</li>
                </ul>
            </ul>
            <p>Transa√ß√µes solicitantes mais VELHAS esperam!</p>
            <p>Transa√ß√µes solicitantes mais NOVAS morrem!</p>
            <p>Exemplo:</p>
            <ul>
                <li>suponha que <b>T2</b>, <b>T3</b> e <b>T4</b> tenham timestamp <b>5</b>, <b>10</b> e <b>15</b> respectivamente. Se <b>T4</b> solicita um item de dado mantido por <b>T3</b>, ent√£o <b>T4</b> ser√° desfeita.</li>
            </ul>
            <p></p>
            <b>Ferir- esperar:</b>
            <ul>
                <li>Quando uma transa√ß√£o Ti solicita um item de dado mantido por Tj:</li>
                <ul>
                    <li>se Ti√© mais nova (timestamp maior) do que Tj, Ti espera;</li>
                    <li>se Ti √© mais velha (timestamp menor) do que TJ, Tj√© desfeita (morrer).</li>
                </ul>
            </ul>
            <p>Transa√ß√µes solicitantes mais NOVAS esperam!</p>
            <p>Transa√ß√µes solicitantes mais VELHAS ferem/matam as mais NOVAS !</p>
            <p>Exemplo:</p>
            <ul>
                <li>suponha que <b>T2</b>, <b>T3</b> e <b>T4</b> tenham timestamp <b>5</b>, <b>10</b> e <b>15</b> respectivamente. Se <b>T2</b> solicita um item de dado mantido por <b>T3</b>, ent√£o o item de dado ser√° liberado por <b>T3</b>, que ser√° ent√£o desfeita.</li>
            </ul>
        </section>

        <section>
            <h2>Detec√ß√£o e recupera√ß√£o.</h2>
            <p>Um mecanismo √© evocado periodicamente para examinar o estado do sistema e determinar se um deadlock est√° ocorrendo.</p>
            <p>Se um deadlock est√° ocorrendo, o mecanismo recupera o sistema tirando-o deste estado.</p>
            <b>Mecanismos de detec√ß√£o e recupera√ß√£o precisam:</b>
            <ul>
                <li>Manter informa√ß√µes sobre aloca√ß√£o corrente dos itens de dados para transa√ß√µes, assim como qualquer solicita√ß√£o de itens de dados pendentes.</li>
                <li>Proporcionar um algoritmo que use essas informa√ß√µes para determinar se o sistema entrou em estado de deadlock.</li>
                <li>Recuperar-se de um deadlock quando o algoritmo de detec√ß√£o determinar que ele ocorreu.</li>
            </ul>
        </section>

        <section>
            <h2>Para detec√ß√£o: abordagem baseada em grafos.</h2>
            <img src="img/transacao7.png" alt="transacao7.png">
            <ul>
                <li>A transa√ß√£o T1 est√° esperando as transa√ß√µes T2 e T3.</li>
                <li>A transa√ß√£o T3 est√° esperando a transa√ß√£o T2.</li>
                <li>A transa√ß√£o T2 est√° esperando a transa√ß√£o T4.</li>
            </ul>
            <p>H√° um ciclo no grafo !!!! O sistema est√° em deadlock:</p>
            <img src="img/transacao8.png" alt="transacao8.png">
            <p></p>
            <b>Para recupera√ß√£o:</b>
            <ul>
                <li>Reverter uma ou mais transa√ß√µes para quebrar o deadlock.</li>
                <ul>
                    <li>1. Selecionar uma transa√ß√£o v√≠tima de acordo com um custo minimo.</li>
                    <li>2. Determinar at√© que ponto a transa√ß√£o deve ser revertida.</li>
                </ul>
            </ul>
            <p><b>INANI√á√ÉO (STARVATION)</b>: √© preciso garantir que uma transa√ß√£o seja escolhida como v√≠tima somente um n√∫mero finito e pequeno de vezes.</p>
            <ul>
                <li>O <b>controle de concorr√™ncia</b> tamb√©m precisa assegurar que os esquemas de execu√ß√£o concorrentes permitam a execu√ß√£o de procedimentos de <b>recupera√ß√£o da falhas</b>.</li>
                <li>Para isso, os esquemas resultantes das execu√ß√µes concorrentes devem ser:</li>
                <ul>
                    <li><b>RECUPER√ÅVEIS</b>: uma transa√ß√£o que depende de outra (usa um dado j√° alterado pela outra naquele esquema de execu√ß√£o concorrente) n√£o pode ser efetivada antes que a outra o seja.</li>
                    <li><b>ESCALAS SEM CASCATA</b>: uma transa√ß√£o usa um dado alterado por outra (naquele esquema de execu√ß√£o concorrente) apenas se a outra j√° foi efetivada.</li>
                </ul>
            </ul>
            <p>O padr√£o SQL define quatro <b>n√≠veis de isolamento</b> de uma transa√ß√£o em termos de tr√™s fen√¥menos que devem ser evitados:</p>
            <ul>
                <li><b>leitura suja</b> (dirty read): uma transa√ß√£o le dados n√£o efetivados (uncommitted) escritos por uma transa√ß√£o concorrente.</li>
                <li><b>leitura que n√£o pode ser repetida</b> (nonrepeatable read): uma transa√ß√£o l√™ uma segunda vez os dados e descobre que eles foram modificados por outra transa√ß√£o (que os efetivou depois de ter sido feita a leitura anterior).</li>
                <li><b>leitura fantasma</b> (phanton read): uma transa√ß√£o executa uma segunda vez uma consulta que retorna um conjunto de linhas que satisfaz uma condi√ß√£o de busca, e descobre que o conjunto de linhas mudou devido a uma outra transa√ß√£o efetivada recentemente.</li>
            </ul>
        </section>

        <section>
            <h2>N√≠veis de Isolamento:</h2>
            <img src="img/transacao9.png" alt="transacao9.png">
        </section>

        <section>
            <h2>Controle de concorr√™ncia - Parte II.</h2>
            <p>Estes slides est√£o baseados na bibliografia:</p>
            <ul><li>Elmasri, Ramez; Navathe, Shamkant B. Sistemas de Banco de Dados. Pearson, 6a edi√ß√£o, 808p., 2011.</li></ul>
        </section>
    </main>
    <footer>
        <p>Diego Serafim de Sousa - 18 de maio de 2024</p>
    </footer>
</body>
</html>
